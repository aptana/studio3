package com.aptana.js.core.parsing;

import com.aptana.parsing.IRecoveryStrategy;
import com.aptana.parsing.ast.IParseNode;
import com.aptana.core.build.IProblem;
import com.aptana.js.core.JSCorePlugin;
import com.aptana.parsing.WorkingParseResult;
import com.aptana.js.core.preferences.IPreferenceConstants;
import java.io.IOException;
import com.aptana.parsing.ast.ParseError;
import java.util.ArrayList;
import java.util.List;
import com.aptana.parsing.IParser;
import com.aptana.parsing.ParseResult;
import org.eclipse.core.runtime.Platform;
import com.aptana.js.core.IJSConstants;
import com.aptana.parsing.IParseState;
import beaver.*;
import com.aptana.js.core.parsing.ast.*;
import com.aptana.parsing.util.ParseUtil;
import com.aptana.parsing.ast.IParseError;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "JS.grammar".
 */
@SuppressWarnings({ "unchecked", "rawtypes" })
public class JSParser extends Parser implements IParser {

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pjNGTy55KJdzdBfLw08264q4CIge28OY4YdG3I554GmT2as501GOeY7QI92e9qYFJUaQu" +
		"WOiUElVU6gBZl##$kozrUSdUv1eVVR$T#i$FAlFdFcvtNDiT1b9L7Rz67D9GIwMQwaRfHTx" +
		"gTUf63Eb8kzQ7twGDQIQieZvvJkjCm6Wx9tjINkb0dwa5TgH$TG6teDkf9Tr0IbQJET2krf" +
		"Lje0Ksa3dGJjQCKQa$zwKuQG0Df40sck#XkkeVkfVje2DrF3z234Z$L3J#kCBv4Z$UAdqO9" +
		"Jlp5N5BYboyItz1RqOolv9hmZNhzhWoWPA$uERGZ7vzBYxCIlxAV#9#vzJ$TG$$pkJVy8tJ" +
		"OsV$Mua#9x$0JFzkCpvTB$8BOjUbIh$WPjCY9$p4zA$6p$CHFSiC$A$6DkXoAfVrqW0xgVV" +
		"I6VxNB$pIQHWNe$nItvzzFuhz0Bz8nYMsat$EAVufdEl6pQRw1ptNyn7$8xVdFSEk$#JxJ6" +
		"putuiOc$7za$rEBmbSo#7T#a9waftWwpQNPz9YMfXfqFOsdH#XHQiXRwJXTHTNfA1tY5mnl" +
		"y6$yAq$YyVmeZ#67kGktuFxSWn$YeJo4#$1Vz0LzoV#ooeA#fUyKHR4fKKeqtyRJU2etfpy" +
		"nMi$nFtnE8OND5l2BV8oFyqjyWdRmQxo3D$CMarMLgQLXbT8tL0kKxag29mi2yG6f8VbWaf" +
		"Bebm#sctt0O$aUmog#3pw83yc2AKfgq3xGnmCiA16I1VkKYaNuOBBkWvEyXI$3fmRNubayY" +
		"tRHRjf3UwayBAWSaWNBbAeX#w1gY3x8Ai875NKVl8euCEOYOox8zq4wB9WVaWKPIerGnm8$" +
		"6v85MSgbHVZWRTq7xy07XMV5R8w21Kj2cWzkK#hvxmEgvUO3tGfOi38a7xoZN5643x9vbxF" +
		"7SQ1Ae6hKY2#ZANmflGiBdWl9We#KguBr0MpuXEl2WdKXpaYDVFfWJn6sPCA2ZI5PyAdIE6" +
		"WVjEHMuYfOy4585anKMlZmmRuYBQaA2puAoOA$bDR1#O2Uf#sqWih1Wiz2ik1VfLqe5l1mM" +
		"F1bA1OmAns2ZeDR#6PMOC5t8LbWLsxo6WVx$V145LZmSqWMn2Ytvbl0LIWwmATGWHrafoZl" +
		"5j3ZcWNq5NrDtsWMqFVq0$r8FvlYmD#8cqDbpHOgtR07VfdByNLy2OtGFdmDboA5cj49$HI" +
		"HJTTG4sgYpW$PmfsSGljmHjd9PMWVr#CAt513u0LkzlIdLlXaSstCazaybxALRfpfNC4bvp" +
		"jeMgZsS3ht3lnPyKYoXUo9R9uN639MpcnUh27pZ92GHs1dM9sVWlTD#DmJ8#LWKLRmO$HRo" +
		"FZPdCUvk6y8sFELw1Tk43A#PwGI7aR9E1fBZQaObQBYbCJR#6NUoNE4Ia$BVSKlT8RMyjsq" +
		"cfwWDRIHwj0LT2MjftLqELr6zQW#RQ2wr81#eXYEvWGId45dkJmdSJAdyXLybH3XqnK#JNo" +
		"AJ#7vd0PzGLF3gFTgQFnMzsGZcXx6dkVmL$mMTF$4Rz2lORJN79#$#nEXF9e7OsRu8wGvAU" +
		"1PGOddQu7gutmT62hFX2#NyKnUm#$oOVu429TmJOozWVmaP$CcVWBrR$BrM1ViJ1Umhu$0a" +
		"ZBS1AW#Jl9XHpqAr7Hk2bGVf$Tmel9485O7rKKCstsTsCE4MatlQxRI47GTg1LGVPpImuHQ" +
		"KwAs1zsepGeNOkJm58bwYz9JkPsRKSe5GNrSGrNku6vyE$UbLBuB7lRn5Y90L6t7zYV$hTH" +
		"IwYlNA4qn7zxBz$ETsBEbyJ2A9sqyRzB6B51zl7a835Lfe$IWYbIUH$0eIkT1r8h7KGPFe2" +
		"mWJURPs5$ivhtAdNm8g3xUDWGuDptF1$W8fGFn21z2UYzANk6tWVMrs2WsYFLYdLWhreZLG" +
		"FNnXY4mLF6So1Ehn4gnGYmNoyHIiKI9LHnYjb92IL9AYKUKqcAiaYR6A9M1wkEjGe0UpXG3" +
		"nMrYj1Wb7XOZnGZna1WkXecXua7nW7X1wII6YFl5KQKNJG6gZpS90QBs9b86aJ#NtTVRWm1" +
		"ZsF$BxkkDmNb4zV6Mu3oY#dWpS1vHVRmDE8#eFju0d4TK7wV#yuUg50$f31FW7bUnynzAib" +
		"9MASOPIenIwNoS6YnDbYPBawN9qcHfYhIcyArt5#FAUJ7spj9aQR8qMPgAq1JetrxUrF$s4" +
		"cYhvY6qSbtNUZovRNQcNW8vZ2IVSfOs3HHNwNC1#$YwrehFKexIKRTsdj84rfyfyhpwS93s" +
		"vKVECpI1rb8BP#GObnOvhz1xUdg31zJJz7TadZtRl7oRwtktlxmKk3Ws9DoTe7qcRQvlCf7" +
		"#RQvVU8ldXyFFEFysJhmqGXvxskkpzZ9BS2A$pcaHihPYeDOgvPJhEIj2rjOFsBV5qEhA25" +
		"dRAs1howBLW0XPkoXWQvUZrUe8MRigO6ink$Bw25dxSS2Zh3nQVHWXQpyFsDhBqUgR25dxO" +
		"y3MDYDIuY9ZhLBIimQbYw$rL4c9p7ggr7Ijfyfb4V9OjK2VhzwgIeIihHEKjLT7oDehWx8s" +
		"EqBMvWJmlKvDGsczLSi8MNj3KBxjV86ilQI0jLq3rd1TKBXZWcerAwXMouDgjJMeLgy5quf" +
		"R1zNgrg1QTG#cbJ8mg5Q3VPvvlSM$zpFo6sISaVCluuoyAPWHvkNQvh5qInWHtl1OUlAyz#" +
		"7LC28GZGodDWuyHdnfMnXMRIl2gcrjMBMz7rPjduPJcr8XhDfgXrMRzpac66tNXbLRyx1gQ" +
		"nkssTUIj#GjUKl#VCi7TBRZhXUT$PQy9M$9M$AMl2KVxlMkJ23ItCz$QNv0$tMkmfVdKk8V" +
		"F9usRlRUZdEybXfN3hVXjjoER#3st84xSYVkp3VoJLvASmheoYcWZGBHLgWZxxdhCbrBYqA" +
		"Wp#NtDuWM#chjvLf22jaeYffGDCLGBCLHF2LGBYLICIfE9IY9sb1RQaSt44l9ifH6vQWyLQ" +
		"2AL8agKnLAfwgKGPjf2rN3Kwv1DV74S#6jEeYtJeYz#eZ01deqDaGSN4tNqBNKYBBfEcgCA" +
		"36qTdJ3J$M0RyXbUiNlGFjC#AaIlxsV#1lSy0#Qy8rwuzwBxl2Aduknbe#VgaUBXh$JJ$nS" +
		"D$nr7lgVpxtXbw9a9twU4p$NJ$nCD$pQ4hyWTacwn2l#3kZ8np#E9s3WR$SJVxCR$Zw9d##" +
		"RezICccDkq$he3N#JoV#Pb1MW$pkvuM#I#3teTkefiOrqdbVyRPXp2#FlzXD$ayVuDyTUKV" +
		"6leHN6xrWaVYxrfZxKb$fHVxUqjr$XCxmnYaRJ61ghp$3ZCEUFn#epaIRHP9f2KsaQJQV7Q" +
		"GRDf5bO4UPWHPghhmfFqpoQZvLg0KRhixI85cF#MUg6keoMOttGVi5nFJs7jMmDrZHN$KwJ" +
		"LQ5Qm5uik70#E1Xn7zX3y84n7aAre6QHFjZgz44DV6hfCykbr99QKMkimkr3jg3sVy076vm" +
		"#C2BFc0loVR0kP0jsH7miR2$I1#pqWQTPCIja2x92y85XnVcomEM3JFZ0rUDygeTnOSUus1" +
		"hHER46BAbrtcOabm#AiYLK2xQ6u0Dj3nnw9EOMuOEYBOba76Y$4ZmqP0kgHTo2j10iqCu97" +
		"B85gJxZm1yx8Xq7eVl0$#Szp4rs5sR6J7Zm44fP$xo8t17CbVNqKqGcEVJFoP0jh0w4cg3g" +
		"q5yJPm06rn1ItUnfgdyowG3coKpCazglwR5p1S$dzM1XwFkPlA2UrQwGaRMrA51ahKteo2n" +
		"Nm8rkc0vzf1HjnTwmzBnfKFr$07Q7ZX$8A1bE3z486aaFwwkLDbFjrLukoNs5tUqSwZ2zXo" +
		"YfVtSlcKfJ2fL1T7ixXuPJL$WqvUAJlr#g5KQzetIDcYVhX5LlBkt1HzEzFynwNP5Ioy#uo" +
		"GjhVFexAnmAA#f6VJNO24h5h92g8#o6F#lXFagVbxNrWa6Hw6jkH533iLFr7pL$zDal8Ahv" +
		"b7JXKRLPuSAZZg9E5n0r5$kDJK3iY7iuKLdVHxa#kT3VKT#nTS0dq$G99seglKGRg3q#6sY" +
		"TlcDRHplmsGwSxUZfHhsdUQWD9se7u6b$frk7kuRU4IMrgGcmgkCSPFw44xLQeG$hzpJTyq" +
		"REe72YrlQ0c$#no$xQqIAyiyHM8QYsyECA9we$U1QgXMgXoZFSnNTgi3HPcYnDbYPBawN9q" +
		"cHfiZHPcYnDbYPlRzJz$zlB1MnbEgCjz7XoE#nC7GFbodIkgzN5tqVQf$t5H5gx7$UZHPvN" +
		"NmuIoKlaIArQv1ocF3rTsWFgjWlhJVEpzqT38Nk3j5QshWwgQTBc$1OFqlBRN5wUpiBylua" +
		"Z$Np4F1RCB16vv$j$Rks5deaiQorhBMijQwtrD5BFDnIFMTPUrDO6gC7oxVdpRGHEQrQh$r" +
		"QhGDTbhsTaoZJEoCverS$8L2#O4UPbfSlqM6eX5DIMPMcpj5dQ$l#qMVAMl2LloKTCFj0zv" +
		"iLcloLloLlobhmbRyc7VxqxVzAmoiFvmMEfyRS4NwM5sr4JRwKobKkTwKQwYRhGpTILRg5R" +
		"gHjrfzkyb3PnrsLytyIb3Ua0j1NgHvwxBbFDjY8HNZ2#lu7w4xvQUxxGcfIxnkW$hXUdWAf" +
		"fQJFXcWwgPwIvhSRHy01HMWENJERV1a#RAjiqGFepo7r8L6uc#Az4bLv5UIdmhy4h4LNMz1" +
		"m1BqCKCnIyhlv$7L3bLgJzVmnKkIVoAAiyp8LJUOQq8wgWdKKHCEwHEbOHHMsGwVrINptKt" +
		"ulyE#0jN6rAFudyVKYeWU9Th4HKuItPvsRI1p$B$4AN37$dIcFs86K4w2yZ7zTEyk5ITgF1" +
		"gyIwsjXA5CQjKWcouxGqdhigTGl9iqrjEqEseIot1z2l9CcRk9V7ZF3TZjiLo3SnfQyeB1$" +
		"JKk8CaNoPPxqq2d66laGj19tsKByFtRC3umJgLQIR6ENsiVxssLrVt7B9NpFP$uh1e#FWqm" +
		"x87oOgtXJvTF3#HbtnQSWZzgDNGwO$RBaMwIsohuaeGp9gA#GsoRBQH2beK#OQzFqSoj#M$" +
		"UaawxlB$4oPbtD2cLaoVvFaAw7xAUZU3XtdPDbkeXALPNeFwZUWVYTHxEs8Yvf6kQsMmQDs" +
		"IFwtgxzLNiGDSqw95g21o7yCFNBEY8LkHZ$Y7Z3oySDTxU8VGzthuAU84kgxohFiKk$Pelp" +
		"lYU37raJf9Q0JyqXwO$3VmBkwwcDx6Jpz7jZvX97cR8CdO0vCdmWEknmvI2#2VJT8cL4k7H" +
		"MgexwDA##8WkmEy5YPnxDFXox7rI0yitHj$aL$QH9HLR0Kn63PjKXZ7kOtCSwx88rvDwOFQ" +
		"2xIc8yLnAeDzbVjwTw$giFSymx4JuaP8FWvPhhiurK6Zn4eVq#cPnDLH0oMaEC$DfKegQfy" +
		"5jqHAz#W7drEQYthHo8jrwdu7gX3l2RDbdMZaPQnK7M6ovQiciYlaZ8OWrNtmxxcu9ZZ7It" +
		"1VmQ7denOy27WbI1u2BmX#efrAWFZnGOxRH#0u0TjhNGC1pq46ePwzDK1lHbZPDynHzgWEn" +
		"wn6dMpB9kC#gUCT2hyLn7ndlIXaOzhJrHIaNtgXRhdaS#ITHsHRYjrB8SEZ8Cuu9QyroZBV" +
		"0DbYFKuh6KbvnPu1XXN3csDknNySb2UBCUQx7WEX77kM0F2CtVWUJlU0Y7k7M#3DD#y2teF" +
		"z3u8VKz4F6Ly31iHB2KnXXodmP5tV8Ib0R7Z#04oy676MSZSXFmleCzGbW0x4Vlnyo1N0sL" +
		"Ve0ppIShdy0N6GyKlKGuVEBv2ETRzp6gGXIsNt8yysYN68$qqU1B6G36a4OE99I5$1ROFq7" +
		"E9Xe6rAG6ofO2VY6Vck1AwVqGz#bqAyrHYCkeHlwKw8LqQzNYsbReXZ$r6OWhg46Ebda4Qi" +
		"H#r2FLNOImWHYezWdBiSH8HbmbjaOQjYMLHFnXrUKJ9w5jY6keUHHfZ9R4Sg3pwW6USWB6L" +
		"33yaLaGUlihiYZBOdepdbrZ9U1PHjo6joI8c4viXVyhr$19Rc9#dKSRxv7F7F968sCsSwAg" +
		"BteZnb5Eu3KtDJsEzNUagZnrjAfVnLAwFgpxj7Oabvw7exmrktoppsz4EyHUR0tu6#U6Q0j" +
		"G$23u8VVa37ECZ$fnBPyALqYRd#FINSCbr9zaqRvORRwf7p2OFAU0ln00ZRkZwGF4kLa8Vr" +
		"xldoots9OzdW$c1$y7SFT#GZv5pJSo40dhs585xt9NEFEXUb$b90LroBs2h4a2$6icslxgN" +
		"qpRVxMpr2#HpJEcftjibVs7myecUw#b7LpggRk7wqYpbUagPD$pjgsUycCC6ZvlZAhFtDU6" +
		"LDJWla79oJnSVRvBfui5EERRZcvlAPe4mxvV#2ULZ97wYUxkORFTyIhmvByjQIDsxNMNnPq" +
		"prlLpfk8C6ZpvZSFfTucmroSk#nKPXhi1PB6M7gNrbjCLw5JT9ujZSROc$tU090rnbKRyPl" +
		"7oXywo$X3tVKQcZgUGzN7K9TqkxVtULnJHsfJFb7ZS1PySonKrzwUzAAvZB4vQuOsOESi$R" +
		"pVgnvqx0N9U0TJbklXOFq84r9huDoh3E97m2$oLA6QpXyGSCsOGFDJlSzIQiBTpVs6Oen$m" +
		"TTqJAV66IDwqVPJIyJrrvHtbJNL$G4fIPvch7R5FzNkHFklA9SGRdfIOxi2Oh6QvyL6t9rq" +
		"kVo7SHqGsaNux3dczXjxQFmHuWVZoujjQdv9DxFvML1hTLTvN5bP0yoLLcMorj$WjxYbBQE" +
		"csoUxGhdOfzOk8kKzqVfhg11YzML$ODuovLuXSRQBRBrIPvkQVoO0XOSkpnQTdtYX9xXKcc" +
		"qBiDx85IfNnFKndE3sMnhocBlPkos5GkrsV551EsT5EwjqaMwx9jkQdkIrSw3UUKDEozeh9" +
		"SPL6cyPBM4$ayKzst1a#M#ziqxEFIS9QqrtJ9s0UPskFiPLzhgZFDy#MA6JowZi7Z$qPPZY" +
		"oxnoMNuBPMQdjNKtglkKxAotShvUMxal9p3AxSfJCI$uf$n06nNqzZ$oyM2EnunLFgJf4ci" +
		"DzKTwWeLO#0NWAz1i8kNSM8Lh4ZLT4Z5POAhNMCm5vNb4Ax555Q98aIehWe9XA5GoI8U14d" +
		"AeeAeeQEW$EYkb8zBEhekIlK5RWZBHg8C#8FyRluJVmgVX4$Yv$4Z#87yRtuJdmhlX5VYw$" +
		"4b#8ByRduJ7mgFX4VYu$4QV6X#42yBzuJxuftnDlYb7XBl2dU4A#BryIhuXLnKhmiJeYNn7" +
		"7nbpWh$XJObGkS#aGLK6Nrk6WehbHV5Ls4$3z6XDONdC34GH1spEfoyQ9wIjmeEejEegCkW" +
		"R4cC4#9fg0ceh5UTftwWVg9#h7waNfQNQmkKfzL5weBL4I3mEb2t21QYnRgL#etwjVgZ#eF" +
		"wlVgT#gtwk$gd#ePzG$r7$LVzPnW4ILiGX4uHOXs8EpuHHlHKhGIpONpVpeHsU9QSOsucfo" +
		"NQ0IwNkmLUyHkiKli53l4Th5DR1LRn6Qn2NMBGOl4i#Z9CZ9TuWctt2ndQgQf5ATeWTL3u8" +
		"Ggi5A8kq686Z7OAJ58TCQzXwdD0D2T8Cp2ee$ehPVT8NhflBj#xoPkmVrcSQkpJLTrkqWLE" +
		"F#eszJDwYPrexf1NQ#kKzUgQzJLwdDgdhfAnQoj7ZBarJsYl2WdClMs6Q2gAfwMUapKraik" +
		"0zKJMLf4YRgYbeezgFgAgA#U17zBnMbJVL$5sLBzNCLfKFr5$HNtiofcM5LL4SR2Bg85pdI" +
		"Yf5WeSi5x2foc1KxQef#k$t5fzNJzFitPYwdwVOhCJTRlaw1rgRfLu9ocRb5nSbMn8geunQ" +
		"ilWt22KR5Agf#2Vb9$LZzJtr5VLq#eHsK$TwdxfRRv0ZEUc2jp4$Nx19aRhzyV4$Da$b4DJ" +
		"K#DKvU8EQwnBPunOXftFLRqb2bMl5skwF0gqRaeYU2k$3uXbUPCdJFL7n67SJycAebBHKsa" +
		"gXdbAdh9lUaaCOZe22aWrdz1k3T5wRzmd4zv$q4QH3OGqq7qwo3IB#d4j1NvhKYFHjeWBQs" +
		"OylxHiqwoWHHJtZyQXJQZq7Ol#5xaZo9z57m$#7xmVJhPQ0$u7l3f50EoqoBmntMoWw9bMg" +
		"DO4zSepiGrYdVMBmPVZFQBqTv8QnHhuXh5cRX6ySxw6R1v1coQ2JuJV1RuBF3PqBa4z0JqF" +
		"W5PWs8bnT5koEr6VpP2TYDYx03o1v2U0reAcWjwqabHz29q7OBCGBJHg4yXib4$rFVJkKPH" +
		"83iTGzqnb1z3sJ6K7KRwCCe6W0z0sG2KdK3#1D8lw6G7HTCsbENJST2TJee2sNIQWFm4v2V" +
		"eQHiDHdumz3uD$ZJuFKwA0jbe8j86HO5ij0dfJU0lwyHqbwJnakxLIQ5vuFF0DuDhTBTE2i" +
		"q7dm#k$PfbKNIVJZPiSXXae#tW#JH49nkD1HyBlWDSe$jrij4Zu8#0hmFFfmTqij6Zu8#2B" +
		"mDV1huUl23jbFIWJZOQ1puEV3duSl0Du6OQYhAXu9F09u6l05y1FWny6FXayCdWAy5NWWy7" +
		"7mu#1NmA#2fmxV$pU0XS#$RNLF2ffFt$7ZOGqqZmaU2FWJy6lXfyDVZ3Ejdf6V1dmDU2hmK" +
		"V0Ju2Cjflo2q0NmE#1dmBU22q46sqV#ip3NmQ#FFWpuFtzK9F$Gy8hitq");

	private WorkingParseResult fWorking;

	// Collect the errors into a list of IParseErrors and let the custom error recovery mechanism handle it
	private class JSEvents extends Events
	{
		public void scannerError(Scanner.Exception e)
		{
		}

		public void syntaxError(Symbol token)
		{
			if (token != null && fWorking != null)
			{
				fWorking.addError(new ParseError(IJSConstants.CONTENT_TYPE_JS, token, IParseError.Severity.ERROR));
			}
		}

		public void unexpectedTokenRemoved(Symbol token)
		{
		}

		public void missingTokenInserted(Symbol token)
		{
		}

		public void missingTokensInserted(List<Symbol> tokens)
		{
			if (tokens != null && tokens.size() == 1 && tokens.get(0).getId() == Terminals.SEMICOLON)
			{
				// remove last error
				if (fWorking != null)
				{
					List<IParseError> errors = fWorking.getErrors();
					IParseError lastError = (errors.isEmpty()) ? null : errors.get(errors.size() - 1);

					if (lastError != null)
					{
						fWorking.removeError(lastError);
					}
				}
			}

			super.missingTokensInserted(tokens);
		}

		public void misspelledTokenReplaced(Symbol token)
		{
		}

		public void errorPhraseRemoved(Symbol error)
		{
		}
	}

	private final List<IRecoveryStrategy> recoveryStrategies;
	private JSFlexScanner fScanner;
	private IProblem.Severity fSemicolonSeverity = IProblem.Severity.WARNING;

    /**
     * attachPostDocumentationBlocks
     * 
     * @param root
     * @param source
     */
    private void attachPostDocumentationBlocks(JSParseRootNode root, String source)
    {
        // process each post-documentation block
        for (Symbol block : this.fScanner.getVSDocComments())
        {
            int index = block.getStart() - 1;

            while (index >= 0 && Character.isWhitespace(source.charAt(index)))
            {
                index--;
            }

            IParseNode node = root.getNodeAtOffset(index);

            if (node instanceof JSNode)
            {
                switch (node.getNodeType())
                {
                    case IJSNodeTypes.STATEMENTS:
                        IParseNode parent = node.getParent();

                        if (parent.getNodeType() == IJSNodeTypes.FUNCTION)
                        {
                            ((JSNode) parent).setPostDocumentation(block);
                        }
                        break;

                    default:
                        ((JSNode) node).setPostDocumentation(block);
                        break;
                }
            }
        }
    }

    /**
     * attachPreDocumentationBlocks
     * 
     * @param root
     * @param source
     */
    private void attachPreDocumentationBlocks(JSParseRootNode root, String source)
    {
        // process each pre-documentation block
        List<Symbol> sDocComments = fScanner.getSDocComments();
        for (Symbol comment : sDocComments)
        {
            int index = comment.getEnd() + 1;

            while (index < source.length() && Character.isWhitespace(source.charAt(index)))
            {
                index++;
            }

            IParseNode node = root.getNodeAtOffset(index);

            if (node instanceof JSNode)
            {
                if (node instanceof JSGroupNode && node.getFirstChild() instanceof JSFunctionNode)
                {
                    ((JSNode) node.getFirstChild()).setPreDocumentation(comment);
                }
                else if (node instanceof JSIdentifierNode && node.getParent() instanceof JSNameValuePairNode)
                {
                    // associate documentation with property's value
                    JSNameValuePairNode entry = (JSNameValuePairNode) node.getParent();
                    ((JSNode) entry.getValue()).setPreDocumentation(comment);
                }
                else
                {
                    IParseNode statement = ((JSNode) node).getContainingStatementNode();

                    if (statement instanceof JSAssignmentNode)
                    {
                        ((JSNode) statement.getLastChild()).setPreDocumentation(comment);
                    }
                    else
                    {
                        switch (node.getNodeType())
                        {
                            case IJSNodeTypes.VAR:
                                // associate documentation with first declared variable's value
                                JSVarNode varNode = (JSVarNode) node;
                                ((JSNode) varNode.getFirstChild().getLastChild()).setPreDocumentation(comment);
                                break;

                            default:
                                ((JSNode) node).setPreDocumentation(comment);
                                break;
                        }
                    }
                }
            }
        }
    }

	/**
	 * getNextSymbolIndex
	 * 
	 * @return
	 */
	protected Symbol getLastSymbol()
	{
		Symbol result = null;

		if (0 <= this.top && this.top < this._symbols.length)
		{
			result = this._symbols[this.top];
		}

		return result;
	}

    public synchronized ParseResult parse(IParseState parseState) throws java.lang.Exception
    {
        WorkingParseResult working = new WorkingParseResult();
        parse(parseState, working);
        return working.getImmutableResult();
    }


	/*
	 * (non-Javadoc)
	 * @see com.aptana.parsing.IParser#parse(com.aptana.parsing.IParseState)
	 */
	protected synchronized void parse(IParseState parseState, WorkingParseResult working) throws java.lang.Exception
	{
		fWorking = working;
		
		String severity = Platform.getPreferencesService().getString(JSCorePlugin.PLUGIN_ID, IPreferenceConstants.PREF_MISSING_SEMICOLON_SEVERITY, null, null);
		fSemicolonSeverity = IProblem.Severity.create(severity);

		// make sure we have some source
		String source = parseState.getSource();

		// create scanner and send source to it
		fScanner = new JSFlexScanner();
		fScanner.setSource(source);

		// determine if we need to collect and/or attach comments
		boolean attachComments = true;
		boolean collectComments = true;

		if (parseState instanceof JSParseState)
		{
			JSParseState jsParseState = (JSParseState) parseState;

			// NOTE: In order to attach comments, we have to collect them, hence the OR in collectComments
			attachComments = jsParseState.attachComments();
			collectComments = jsParseState.attachComments() || jsParseState.collectComments();
		}

		fScanner.setCollectComments(collectComments);

		try
		{
			JSParseRootNode result;
			try
			{
				// parse
				result = (JSParseRootNode) parse(fScanner);
				System.out.println("Result Beaver:"+ result);
				if (attachComments)
				{
					attachComments(source, result);
				}

				if (collectComments)
				{
					collectComments(result);
				}
			}
			finally
			{
				// clear scanner for garbage collection
				if (fScanner != null)
				{
					fScanner.yyclose();
					fScanner = null;
				}
			}
			
			System.out.println("errors...:"+ working.getErrors());

			//clear beaver parser working result errors
			working.getErrors().clear();
			
			//collect errors from the GraalJS Parser
			GraalJSParser graalJSParser = new GraalJSParser();
			graalJSParser.parse(parseState, working);
			
			// update node offsets
			int start = parseState.getStartingOffset();
			int length = source.length();

			// align root with zero-based offset
			result.setLocation(0, length - 1);

			if (start != 0)
			{
				// shift all offsets to the correct position
				ParseUtil.addOffset(result, start);
			}
			
			System.out.println("GraalJS parser errors:"+ working.getErrors());
			fWorking.setParseResult(result);
		}
		finally
		{
			fWorking = null;
		} 
	}

	
    private void attachComments(String source, JSParseRootNode result)
    {
        // attach documentation
        attachPreDocumentationBlocks(result, source);
        attachPostDocumentationBlocks(result, source);
    }

    private void collectComments(JSParseRootNode result)
    {
        // create a list of all comments and attach to root node

        List<Symbol> sDocComments = fScanner.getSDocComments();
        List<Symbol> vsDocComments = fScanner.getVSDocComments();
        List<Symbol> singleLineComments = fScanner.getSingleLineComments();
        List<Symbol> multiLineComments = fScanner.getMultiLineComments();

        List<JSCommentNode> comments = new ArrayList<JSCommentNode>(sDocComments.size() + vsDocComments.size()
                + singleLineComments.size() + multiLineComments.size());

        for (Symbol symbol : sDocComments)
        {
            comments.add(new JSCommentNode(IJSNodeTypes.SDOC_COMMENT, symbol.getStart(), symbol.getEnd()));
        }

        for (Symbol symbol : vsDocComments)
        {
            comments.add(new JSCommentNode(IJSNodeTypes.VSDOC_COMMENT, symbol.getStart(), symbol.getEnd()));
        }

        for (Symbol symbol : singleLineComments)
        {
            comments.add(new JSCommentNode(IJSNodeTypes.SINGLE_LINE_COMMENT, symbol.getStart(), symbol.getEnd()));
        }

        for (Symbol symbol : multiLineComments)
        {
            comments.add(new JSCommentNode(IJSNodeTypes.MULTI_LINE_COMMENT, symbol.getStart(), symbol.getEnd()));
        }

        result.setCommentNodes(comments.toArray(new IParseNode[comments.size()]));
    }

	/*
	 * (non-Javadoc)
	 * @see beaver.Parser#recoverFromError(beaver.Symbol, beaver.Parser.TokenStream)
	 */
	@Override
	protected void recoverFromError(Symbol token, TokenStream in) throws IOException, Parser.Exception
	{
		boolean success = false;

		if (this.recoveryStrategies != null)
		{
			// NOTE: Consider building a Map<Object,List<IRecoveryStrategy>> which
			// would allow us to reduce the number of recovery strategies that will
			// be attempted based on the last symbol on the stack. We may need
			// catch-all cases: 1) try these before the mapped strategies, 2)
			// try the strategies, 3) try these after the mapped strategies
			for (IRecoveryStrategy strategy : this.recoveryStrategies)
			{
				if (strategy.recover(this, getLastSymbol(), token, in, report))
				{
					success = true;
					break;
				}
			}
		}

		if (success == false)
		{
			super.recoverFromError(token, in);
		}
	}

	public JSParser() {
		super(PARSING_TABLES);


		report = new JSEvents();

		// @formatter:off
		recoveryStrategies = new ArrayList<IRecoveryStrategy>(10);

		recoveryStrategies.add(new JSInsertionRecoveryStrategy(JSTokenType.SEMICOLON, ";")
		{
			public boolean recover(IParser parser, Symbol lastToken, Symbol currentToken, TokenStream in, Events report)
					throws IOException
			{
				boolean recovered = super.recover(parser, lastToken, currentToken, in, report);
				if (recovered && fSemicolonSeverity != IProblem.Severity.IGNORE)
				{
					fWorking.addError(new ParseError(IJSConstants.CONTENT_TYPE_JS, lastToken, Messages.JSParser_MissingSemicolonMsg, fSemicolonSeverity));
				}
				return recovered;
			}
		});
		recoveryStrategies.add(new JSInsertionRecoveryStrategy(JSTokenType.RPAREN, ")", JSTokenType.SEMICOLON, ";"));
		recoveryStrategies.add(new JSInsertionRecoveryStrategy(JSTokenType.IDENTIFIER, "", JSTokenType.SEMICOLON, ";", JSTokenType.DOT, JSTokenType.NEW, JSTokenType.EQUAL));
		recoveryStrategies.add(new JSInsertionRecoveryStrategy(JSTokenType.IDENTIFIER, "", JSTokenType.DOT, JSTokenType.NEW, JSTokenType.EQUAL));
		recoveryStrategies.add(new JSInsertionRecoveryStrategy(JSTokenType.IDENTIFIER, "", JSTokenType.LPAREN));
		recoveryStrategies.add(new JSInsertionRecoveryStrategy(JSTokenType.IDENTIFIER, "", JSTokenType.COLON, ":", JSTokenType.DOT));
		recoveryStrategies.add(new JSInsertionRecoveryStrategy(JSTokenType.LCURLY, "{", JSTokenType.RCURLY, "}", JSTokenType.RPAREN));
		recoveryStrategies.add(new IRecoveryStrategy()
		{
			public boolean recover(IParser parser, Symbol lastToken, Symbol currentToken, TokenStream in, Parser.Events report) throws IOException
			{
				boolean result = false;

				if (top >= 2)
				{
					Symbol symbol1 = _symbols[top - 2];
					Symbol symbol2 = _symbols[top - 1];

					if (lastToken.getId() == JSTokenType.COMMA.getIndex() && symbol2.value instanceof List<?> && symbol1.getId() == JSTokenType.LPAREN.getIndex())
					{
						Symbol term = new Symbol(JSTokenType.IDENTIFIER.getIndex(), currentToken.getStart(), currentToken.getStart() - 1, "");
						Simulator sim = new Simulator();

						in.alloc(2);
						in.insert(term, currentToken);
						in.rewind();

						if (sim.parse(in))
						{
							result = true;

							in.rewind();

							report.missingTokenInserted(term);
						}
					}
				}

				return result;
			}
		});

		JSInsertionRecoveryStrategy completeProperty = new JSInsertionRecoveryStrategy(JSTokenType.IDENTIFIER, "");
		completeProperty.addCurrentTokenTypes(JSTokenType.RCURLY);
		recoveryStrategies.add(completeProperty);

		JSInsertionRecoveryStrategy completeProperty2 = new JSInsertionRecoveryStrategy(JSTokenType.COLON, ":", JSTokenType.IDENTIFIER, "");
		completeProperty2.addCurrentTokenTypes(JSTokenType.RCURLY);
		recoveryStrategies.add(completeProperty2);
		// @formatter:on
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		switch(rule_num) {
			case 0: // Program = SourceElements.p
			{
					final Symbol _symbol_p = _symbols[offset + 1];
					final ArrayList _list_p = (ArrayList) _symbol_p.value;
					final JSNode[] p = _list_p == null ? new JSNode[0] : (JSNode[]) _list_p.toArray(new JSNode[_list_p.size()]);
					
			return new JSParseRootNode(p);
			}
			case 1: // Program = 
			{
					
			return new JSParseRootNode();
			}
			case 2: // SourceElements = SourceElements SourceElement
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
			}
			case 3: // SourceElements = SourceElement
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 5: // FunctionDeclaration = FUNCTION Identifier.ident FunctionParameters.params FunctionBody.body
			{
					final Symbol ident = _symbols[offset + 2];
					final Symbol _symbol_params = _symbols[offset + 3];
					final JSNode params = (JSNode) _symbol_params.value;
					final Symbol _symbol_body = _symbols[offset + 4];
					final JSNode body = (JSNode) _symbol_body.value;
					
			return new JSFunctionNode(
				new JSIdentifierNode(ident),
				params,
				body
			);
			}
			case 54: // FunctionExpression = FUNCTION.f FunctionParameters.params FunctionBody.body
			{
					final Symbol f = _symbols[offset + 1];
					final Symbol _symbol_params = _symbols[offset + 2];
					final JSNode params = (JSNode) _symbol_params.value;
					final Symbol _symbol_body = _symbols[offset + 3];
					final JSNode body = (JSNode) _symbol_body.value;
					
			return new JSFunctionNode(
				new JSEmptyNode(f),
				params,
				body
			);
			}
			case 56: // FunctionParameters = LPAREN RPAREN
			{
					
			return new JSParametersNode();
			}
			case 57: // FunctionParameters = LPAREN FormalParameterList.params RPAREN
			{
					final Symbol _symbol_params = _symbols[offset + 2];
					final JSNode params = (JSNode) _symbol_params.value;
					
			return params;
			}
			case 58: // FormalParameterList = FormalParameterList.list COMMA Identifier.ident
			{
					final Symbol _symbol_list = _symbols[offset + 1];
					final JSNode list = (JSNode) _symbol_list.value;
					final Symbol ident = _symbols[offset + 3];
					
			JSNode identifier = new JSIdentifierNode(ident);

			// add identifier to existing list
			list.addChild(identifier);

			return list;
			}
			case 59: // FormalParameterList = Identifier.ident
			{
					final Symbol ident = _symbols[offset + 1];
					
			JSNode identifier = new JSIdentifierNode(ident);

			return new JSParametersNode(identifier);
			}
			case 60: // FunctionBody = LCURLY RCURLY
			{
					
			return new JSStatementsNode();
			}
			case 61: // FunctionBody = LCURLY SourceElements.s RCURLY
			{
					final Symbol _symbol_s = _symbols[offset + 2];
					final ArrayList _list_s = (ArrayList) _symbol_s.value;
					final JSNode[] s = _list_s == null ? new JSNode[0] : (JSNode[]) _list_s.toArray(new JSNode[_list_s.size()]);
					
			return new JSStatementsNode(s);
			}
			case 64: // Statement = VAR.v VariableDeclarationList.l SEMICOLON.s
			{
					final Symbol v = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final ArrayList _list_l = (ArrayList) _symbol_l.value;
					final JSNode[] l = _list_l == null ? new JSNode[0] : (JSNode[]) _list_l.toArray(new JSNode[_list_l.size()]);
					final Symbol s = _symbols[offset + 3];
					
			JSNode node = new JSVarNode(v, l);
			node.setSemicolonIncluded(s.getEnd() >= s.getStart());
			return node;
			}
			case 65: // Statement = Expression_NoLBF.e SEMICOLON
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final JSNode e = (JSNode) _symbol_e.value;
					
			e.setSemicolonIncluded(true);
			return e;
			}
			case 76: // Statement = SEMICOLON.s
			{
					final Symbol s = _symbols[offset + 1];
					
			JSNode node = new JSEmptyNode(s);
			node.setSemicolonIncluded(true);
			return node;
			}
			case 77: // Statement = error
			{
					
			return new JSErrorNode();
			}
			case 80: // Statement_NoIf = VAR.v VariableDeclarationList.l SEMICOLON
			{
					final Symbol v = _symbols[offset + 1];
					final Symbol _symbol_l = _symbols[offset + 2];
					final ArrayList _list_l = (ArrayList) _symbol_l.value;
					final JSNode[] l = _list_l == null ? new JSNode[0] : (JSNode[]) _list_l.toArray(new JSNode[_list_l.size()]);
					
			JSNode node = new JSVarNode(v, l);
			node.setSemicolonIncluded(true);
			return node;
			}
			case 81: // Statement_NoIf = Expression_NoLBF.e SEMICOLON
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final JSNode e = (JSNode) _symbol_e.value;
					
			e.setSemicolonIncluded(true);
			return e;
			}
			case 92: // Statement_NoIf = SEMICOLON.s
			{
					final Symbol s = _symbols[offset + 1];
					
			return new JSEmptyNode(s);
			}
			case 93: // Statement_NoIf = error
			{
					
			return new JSErrorNode();
			}
			case 94: // Block = LCURLY RCURLY
			{
					
			return new JSStatementsNode();
			}
			case 95: // Block = LCURLY StatementList.a RCURLY
			{
					final Symbol _symbol_a = _symbols[offset + 2];
					final ArrayList _list_a = (ArrayList) _symbol_a.value;
					final JSNode[] a = _list_a == null ? new JSNode[0] : (JSNode[]) _list_a.toArray(new JSNode[_list_a.size()]);
					
			return new JSStatementsNode(a);
			}
			case 96: // StatementList = StatementList Statement
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
			}
			case 97: // StatementList = Statement
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 98: // VariableDeclarationList = VariableDeclarationList COMMA VariableDeclaration
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
			}
			case 99: // VariableDeclarationList = VariableDeclaration
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 100: // VariableDeclarationList_NoIn = VariableDeclarationList_NoIn COMMA VariableDeclaration_NoIn
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
			}
			case 101: // VariableDeclarationList_NoIn = VariableDeclaration_NoIn
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 102: // VariableDeclaration = Identifier.i
			{
					final Symbol i = _symbols[offset + 1];
					
			return new JSDeclarationNode(new JSIdentifierNode(i), null, new JSEmptyNode(i));
			}
			case 103: // VariableDeclaration = Identifier.i EQUAL.e AssignmentExpression.expression
			{
					final Symbol i = _symbols[offset + 1];
					final Symbol e = _symbols[offset + 2];
					final Symbol _symbol_expression = _symbols[offset + 3];
					final JSNode expression = (JSNode) _symbol_expression.value;
					
			return new JSDeclarationNode(new JSIdentifierNode(i), e, expression);
			}
			case 104: // VariableDeclaration_NoIn = Identifier.i
			{
					final Symbol i = _symbols[offset + 1];
					
			return new JSDeclarationNode(new JSIdentifierNode(i), null, new JSEmptyNode(i));
			}
			case 105: // VariableDeclaration_NoIn = Identifier.i EQUAL.e AssignmentExpression_NoIn.expression
			{
					final Symbol i = _symbols[offset + 1];
					final Symbol e = _symbols[offset + 2];
					final Symbol _symbol_expression = _symbols[offset + 3];
					final JSNode expression = (JSNode) _symbol_expression.value;
					
			return new JSDeclarationNode(new JSIdentifierNode(i), e, expression);
			}
			case 106: // IfStatement = IF LPAREN.l Expression.e RPAREN.r Statement_NoIf.sn ELSE Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol r = _symbols[offset + 4];
					final Symbol _symbol_sn = _symbols[offset + 5];
					final JSNode sn = (JSNode) _symbol_sn.value;
					final Symbol _symbol_s = _symbols[offset + 7];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSIfNode(l, e, r, sn, s);
			}
			case 107: // IfStatement = IF LPAREN.l Expression.e RPAREN.r Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol r = _symbols[offset + 4];
					final Symbol _symbol_s = _symbols[offset + 5];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSIfNode(l, e, r, s, new JSEmptyNode(s));
			}
			case 108: // IfStatement_NoIf = IF LPAREN.l Expression.e RPAREN.r Statement_NoIf.sn ELSE Statement_NoIf.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol r = _symbols[offset + 4];
					final Symbol _symbol_sn = _symbols[offset + 5];
					final JSNode sn = (JSNode) _symbol_sn.value;
					final Symbol _symbol_s = _symbols[offset + 7];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSIfNode(l, e, r, sn, s);
			}
			case 109: // IterationStatement = DO Statement.s WHILE LPAREN.l Expression.e RPAREN.r SEMICOLON
			{
					final Symbol _symbol_s = _symbols[offset + 2];
					final JSNode s = (JSNode) _symbol_s.value;
					final Symbol l = _symbols[offset + 4];
					final Symbol _symbol_e = _symbols[offset + 5];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol r = _symbols[offset + 6];
					
			JSNode node = new JSDoNode(s, l, e, r);
			node.setSemicolonIncluded(true);
			return node;
			}
			case 110: // IterationStatement = WHILE LPAREN.l Expression.e RPAREN.r Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol r = _symbols[offset + 4];
					final Symbol _symbol_s = _symbols[offset + 5];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSWhileNode(l, e, r, s);
			}
			case 111: // IterationStatement = FOR LPAREN.l SEMICOLON.s1 SEMICOLON.s2 RPAREN.r Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol s1 = _symbols[offset + 3];
					final Symbol s2 = _symbols[offset + 4];
					final Symbol r = _symbols[offset + 5];
					final Symbol _symbol_s = _symbols[offset + 6];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForNode(l, new JSEmptyNode(l), s1, new JSEmptyNode(s1), s2, new JSEmptyNode(s2), r, s);
			}
			case 112: // IterationStatement = FOR LPAREN.l SEMICOLON.s1 SEMICOLON.s2 Expression.a RPAREN.r Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol s1 = _symbols[offset + 3];
					final Symbol s2 = _symbols[offset + 4];
					final Symbol _symbol_a = _symbols[offset + 5];
					final JSNode a = (JSNode) _symbol_a.value;
					final Symbol r = _symbols[offset + 6];
					final Symbol _symbol_s = _symbols[offset + 7];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForNode(l, new JSEmptyNode(l), s1, new JSEmptyNode(s1), s2, a, r, s);
			}
			case 113: // IterationStatement = FOR LPAREN.l SEMICOLON.s1 Expression.c SEMICOLON.s2 RPAREN.r Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol s1 = _symbols[offset + 3];
					final Symbol _symbol_c = _symbols[offset + 4];
					final JSNode c = (JSNode) _symbol_c.value;
					final Symbol s2 = _symbols[offset + 5];
					final Symbol r = _symbols[offset + 6];
					final Symbol _symbol_s = _symbols[offset + 7];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForNode(l, new JSEmptyNode(l), s1, c, s2, new JSEmptyNode(s2), r, s);
			}
			case 114: // IterationStatement = FOR LPAREN.l SEMICOLON.s1 Expression.c SEMICOLON.s2 Expression.a RPAREN.r Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol s1 = _symbols[offset + 3];
					final Symbol _symbol_c = _symbols[offset + 4];
					final JSNode c = (JSNode) _symbol_c.value;
					final Symbol s2 = _symbols[offset + 5];
					final Symbol _symbol_a = _symbols[offset + 6];
					final JSNode a = (JSNode) _symbol_a.value;
					final Symbol r = _symbols[offset + 7];
					final Symbol _symbol_s = _symbols[offset + 8];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForNode(l, new JSEmptyNode(l), s1, c, s2, a, r, s);
			}
			case 115: // IterationStatement = FOR LPAREN.l Expression_NoIn.i SEMICOLON.s1 SEMICOLON.s2 RPAREN.r Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final JSNode i = (JSNode) _symbol_i.value;
					final Symbol s1 = _symbols[offset + 4];
					final Symbol s2 = _symbols[offset + 5];
					final Symbol r = _symbols[offset + 6];
					final Symbol _symbol_s = _symbols[offset + 7];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForNode(l, i, s1, new JSEmptyNode(s1), s2, new JSEmptyNode(s2), r, s);
			}
			case 116: // IterationStatement = FOR LPAREN.l Expression_NoIn.i SEMICOLON.s1 SEMICOLON.s2 Expression.a RPAREN.r Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final JSNode i = (JSNode) _symbol_i.value;
					final Symbol s1 = _symbols[offset + 4];
					final Symbol s2 = _symbols[offset + 5];
					final Symbol _symbol_a = _symbols[offset + 6];
					final JSNode a = (JSNode) _symbol_a.value;
					final Symbol r = _symbols[offset + 7];
					final Symbol _symbol_s = _symbols[offset + 8];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForNode(l, i, s1, new JSEmptyNode(s1), s2, a, r, s);
			}
			case 117: // IterationStatement = FOR LPAREN.l Expression_NoIn.i SEMICOLON.s1 Expression.c SEMICOLON.s2 RPAREN.r Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final JSNode i = (JSNode) _symbol_i.value;
					final Symbol s1 = _symbols[offset + 4];
					final Symbol _symbol_c = _symbols[offset + 5];
					final JSNode c = (JSNode) _symbol_c.value;
					final Symbol s2 = _symbols[offset + 6];
					final Symbol r = _symbols[offset + 7];
					final Symbol _symbol_s = _symbols[offset + 8];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForNode(l, i, s1, c, s2, new JSEmptyNode(s2), r, s);
			}
			case 118: // IterationStatement = FOR LPAREN.l Expression_NoIn.i SEMICOLON.s1 Expression.c SEMICOLON.s2 Expression.a RPAREN.r Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final JSNode i = (JSNode) _symbol_i.value;
					final Symbol s1 = _symbols[offset + 4];
					final Symbol _symbol_c = _symbols[offset + 5];
					final JSNode c = (JSNode) _symbol_c.value;
					final Symbol s2 = _symbols[offset + 6];
					final Symbol _symbol_a = _symbols[offset + 7];
					final JSNode a = (JSNode) _symbol_a.value;
					final Symbol r = _symbols[offset + 8];
					final Symbol _symbol_s = _symbols[offset + 9];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForNode(l, i, s1, c, s2, a, r, s);
			}
			case 119: // IterationStatement = FOR LPAREN.l VAR.v VariableDeclarationList_NoIn.i SEMICOLON.s1 SEMICOLON.s2 RPAREN.r Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol v = _symbols[offset + 3];
					final Symbol _symbol_i = _symbols[offset + 4];
					final ArrayList _list_i = (ArrayList) _symbol_i.value;
					final JSNode[] i = _list_i == null ? new JSNode[0] : (JSNode[]) _list_i.toArray(new JSNode[_list_i.size()]);
					final Symbol s1 = _symbols[offset + 5];
					final Symbol s2 = _symbols[offset + 6];
					final Symbol r = _symbols[offset + 7];
					final Symbol _symbol_s = _symbols[offset + 8];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForNode(l, new JSVarNode(v, i), s1, new JSEmptyNode(s1), s2, new JSEmptyNode(s2), r, s);
			}
			case 120: // IterationStatement = FOR LPAREN.l VAR.v VariableDeclarationList_NoIn.i SEMICOLON.s1 SEMICOLON.s2 Expression.a RPAREN.r Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol v = _symbols[offset + 3];
					final Symbol _symbol_i = _symbols[offset + 4];
					final ArrayList _list_i = (ArrayList) _symbol_i.value;
					final JSNode[] i = _list_i == null ? new JSNode[0] : (JSNode[]) _list_i.toArray(new JSNode[_list_i.size()]);
					final Symbol s1 = _symbols[offset + 5];
					final Symbol s2 = _symbols[offset + 6];
					final Symbol _symbol_a = _symbols[offset + 7];
					final JSNode a = (JSNode) _symbol_a.value;
					final Symbol r = _symbols[offset + 8];
					final Symbol _symbol_s = _symbols[offset + 9];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForNode(l, new JSVarNode(v, i), s1, new JSEmptyNode(s1), s2, a, r, s);
			}
			case 121: // IterationStatement = FOR LPAREN.l VAR.v VariableDeclarationList_NoIn.i SEMICOLON.s1 Expression.c SEMICOLON.s2 RPAREN.r Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol v = _symbols[offset + 3];
					final Symbol _symbol_i = _symbols[offset + 4];
					final ArrayList _list_i = (ArrayList) _symbol_i.value;
					final JSNode[] i = _list_i == null ? new JSNode[0] : (JSNode[]) _list_i.toArray(new JSNode[_list_i.size()]);
					final Symbol s1 = _symbols[offset + 5];
					final Symbol _symbol_c = _symbols[offset + 6];
					final JSNode c = (JSNode) _symbol_c.value;
					final Symbol s2 = _symbols[offset + 7];
					final Symbol r = _symbols[offset + 8];
					final Symbol _symbol_s = _symbols[offset + 9];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForNode(l, new JSVarNode(v, i), s1, c, s2, new JSEmptyNode(s2), r, s);
			}
			case 122: // IterationStatement = FOR LPAREN.l VAR.v VariableDeclarationList_NoIn.i SEMICOLON.s1 Expression.c SEMICOLON.s2 Expression.a RPAREN.r Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol v = _symbols[offset + 3];
					final Symbol _symbol_i = _symbols[offset + 4];
					final ArrayList _list_i = (ArrayList) _symbol_i.value;
					final JSNode[] i = _list_i == null ? new JSNode[0] : (JSNode[]) _list_i.toArray(new JSNode[_list_i.size()]);
					final Symbol s1 = _symbols[offset + 5];
					final Symbol _symbol_c = _symbols[offset + 6];
					final JSNode c = (JSNode) _symbol_c.value;
					final Symbol s2 = _symbols[offset + 7];
					final Symbol _symbol_a = _symbols[offset + 8];
					final JSNode a = (JSNode) _symbol_a.value;
					final Symbol r = _symbols[offset + 9];
					final Symbol _symbol_s = _symbols[offset + 10];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForNode(l, new JSVarNode(v, i), s1, c, s2, a, r, s);
			}
			case 123: // IterationStatement = FOR LPAREN.l LeftHandSideExpression.i IN.in Expression.o RPAREN.r Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final JSNode i = (JSNode) _symbol_i.value;
					final Symbol in = _symbols[offset + 4];
					final Symbol _symbol_o = _symbols[offset + 5];
					final JSNode o = (JSNode) _symbol_o.value;
					final Symbol r = _symbols[offset + 6];
					final Symbol _symbol_s = _symbols[offset + 7];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForInNode(l, i, in, o, r, s);
			}
			case 124: // IterationStatement = FOR LPAREN.l VAR.v VariableDeclaration_NoIn.i IN.in Expression.o RPAREN.r Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol v = _symbols[offset + 3];
					final Symbol _symbol_i = _symbols[offset + 4];
					final JSNode i = (JSNode) _symbol_i.value;
					final Symbol in = _symbols[offset + 5];
					final Symbol _symbol_o = _symbols[offset + 6];
					final JSNode o = (JSNode) _symbol_o.value;
					final Symbol r = _symbols[offset + 7];
					final Symbol _symbol_s = _symbols[offset + 8];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForInNode(l, new JSVarNode(v, i), in, o, r, s);
			}
			case 125: // IterationStatement_NoIf = DO Statement.s WHILE LPAREN.l Expression.e RPAREN.r SEMICOLON
			{
					final Symbol _symbol_s = _symbols[offset + 2];
					final JSNode s = (JSNode) _symbol_s.value;
					final Symbol l = _symbols[offset + 4];
					final Symbol _symbol_e = _symbols[offset + 5];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol r = _symbols[offset + 6];
					
			JSNode node = new JSDoNode(s, l, e, r);
			node.setSemicolonIncluded(true);
			return node;
			}
			case 126: // IterationStatement_NoIf = WHILE LPAREN.l Expression.e RPAREN.r Statement_NoIf.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol r = _symbols[offset + 4];
					final Symbol _symbol_s = _symbols[offset + 5];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSWhileNode(l, e, r, s);
			}
			case 127: // IterationStatement_NoIf = FOR LPAREN.l SEMICOLON.s1 SEMICOLON.s2 RPAREN.r Statement_NoIf.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol s1 = _symbols[offset + 3];
					final Symbol s2 = _symbols[offset + 4];
					final Symbol r = _symbols[offset + 5];
					final Symbol _symbol_s = _symbols[offset + 6];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForNode(l, new JSEmptyNode(l), s1, new JSEmptyNode(s1), s2, new JSEmptyNode(s2), r, s);
			}
			case 128: // IterationStatement_NoIf = FOR LPAREN.l SEMICOLON.s1 SEMICOLON.s2 Expression.a RPAREN.r Statement_NoIf.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol s1 = _symbols[offset + 3];
					final Symbol s2 = _symbols[offset + 4];
					final Symbol _symbol_a = _symbols[offset + 5];
					final JSNode a = (JSNode) _symbol_a.value;
					final Symbol r = _symbols[offset + 6];
					final Symbol _symbol_s = _symbols[offset + 7];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForNode(l, new JSEmptyNode(l), s1, new JSEmptyNode(s1), s2, a, r, s);
			}
			case 129: // IterationStatement_NoIf = FOR LPAREN.l SEMICOLON.s1 Expression.c SEMICOLON.s2 RPAREN.r Statement_NoIf.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol s1 = _symbols[offset + 3];
					final Symbol _symbol_c = _symbols[offset + 4];
					final JSNode c = (JSNode) _symbol_c.value;
					final Symbol s2 = _symbols[offset + 5];
					final Symbol r = _symbols[offset + 6];
					final Symbol _symbol_s = _symbols[offset + 7];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForNode(l, new JSEmptyNode(l), s1, c, s2, new JSEmptyNode(s2), r, s);
			}
			case 130: // IterationStatement_NoIf = FOR LPAREN.l SEMICOLON.s1 Expression.c SEMICOLON.s2 Expression.a RPAREN.r Statement_NoIf.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol s1 = _symbols[offset + 3];
					final Symbol _symbol_c = _symbols[offset + 4];
					final JSNode c = (JSNode) _symbol_c.value;
					final Symbol s2 = _symbols[offset + 5];
					final Symbol _symbol_a = _symbols[offset + 6];
					final JSNode a = (JSNode) _symbol_a.value;
					final Symbol r = _symbols[offset + 7];
					final Symbol _symbol_s = _symbols[offset + 8];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForNode(l, new JSEmptyNode(l), s1, c, s2, a, r, s);
			}
			case 131: // IterationStatement_NoIf = FOR LPAREN.l Expression_NoIn.i SEMICOLON.s1 SEMICOLON.s2 RPAREN.r Statement_NoIf.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final JSNode i = (JSNode) _symbol_i.value;
					final Symbol s1 = _symbols[offset + 4];
					final Symbol s2 = _symbols[offset + 5];
					final Symbol r = _symbols[offset + 6];
					final Symbol _symbol_s = _symbols[offset + 7];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForNode(l, i, s1, new JSEmptyNode(s1), s2, new JSEmptyNode(s2), r, s);
			}
			case 132: // IterationStatement_NoIf = FOR LPAREN.l Expression_NoIn.i SEMICOLON.s1 SEMICOLON.s2 Expression.a RPAREN.r Statement_NoIf.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final JSNode i = (JSNode) _symbol_i.value;
					final Symbol s1 = _symbols[offset + 4];
					final Symbol s2 = _symbols[offset + 5];
					final Symbol _symbol_a = _symbols[offset + 6];
					final JSNode a = (JSNode) _symbol_a.value;
					final Symbol r = _symbols[offset + 7];
					final Symbol _symbol_s = _symbols[offset + 8];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForNode(l, i, s1, new JSEmptyNode(s1), s2, a, r, s);
			}
			case 133: // IterationStatement_NoIf = FOR LPAREN.l Expression_NoIn.i SEMICOLON.s1 Expression.c SEMICOLON.s2 RPAREN.r Statement_NoIf.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final JSNode i = (JSNode) _symbol_i.value;
					final Symbol s1 = _symbols[offset + 4];
					final Symbol _symbol_c = _symbols[offset + 5];
					final JSNode c = (JSNode) _symbol_c.value;
					final Symbol s2 = _symbols[offset + 6];
					final Symbol r = _symbols[offset + 7];
					final Symbol _symbol_s = _symbols[offset + 8];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForNode(l, i, s1, c, s2, new JSEmptyNode(s2), r, s);
			}
			case 134: // IterationStatement_NoIf = FOR LPAREN.l Expression_NoIn.i SEMICOLON.s1 Expression.c SEMICOLON.s2 Expression.a RPAREN.r Statement_NoIf.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final JSNode i = (JSNode) _symbol_i.value;
					final Symbol s1 = _symbols[offset + 4];
					final Symbol _symbol_c = _symbols[offset + 5];
					final JSNode c = (JSNode) _symbol_c.value;
					final Symbol s2 = _symbols[offset + 6];
					final Symbol _symbol_a = _symbols[offset + 7];
					final JSNode a = (JSNode) _symbol_a.value;
					final Symbol r = _symbols[offset + 8];
					final Symbol _symbol_s = _symbols[offset + 9];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForNode(l, i, s1, c, s2, a, r, s);
			}
			case 135: // IterationStatement_NoIf = FOR LPAREN.l VAR.v VariableDeclarationList_NoIn.i SEMICOLON.s1 SEMICOLON.s2 RPAREN.r Statement_NoIf.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol v = _symbols[offset + 3];
					final Symbol _symbol_i = _symbols[offset + 4];
					final ArrayList _list_i = (ArrayList) _symbol_i.value;
					final JSNode[] i = _list_i == null ? new JSNode[0] : (JSNode[]) _list_i.toArray(new JSNode[_list_i.size()]);
					final Symbol s1 = _symbols[offset + 5];
					final Symbol s2 = _symbols[offset + 6];
					final Symbol r = _symbols[offset + 7];
					final Symbol _symbol_s = _symbols[offset + 8];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForNode(l, new JSVarNode(v, i), s1, new JSEmptyNode(s1), s2, new JSEmptyNode(s2), r, s);
			}
			case 136: // IterationStatement_NoIf = FOR LPAREN.l VAR.v VariableDeclarationList_NoIn.i SEMICOLON.s1 SEMICOLON.s2 Expression.a RPAREN.r Statement_NoIf.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol v = _symbols[offset + 3];
					final Symbol _symbol_i = _symbols[offset + 4];
					final ArrayList _list_i = (ArrayList) _symbol_i.value;
					final JSNode[] i = _list_i == null ? new JSNode[0] : (JSNode[]) _list_i.toArray(new JSNode[_list_i.size()]);
					final Symbol s1 = _symbols[offset + 5];
					final Symbol s2 = _symbols[offset + 6];
					final Symbol _symbol_a = _symbols[offset + 7];
					final JSNode a = (JSNode) _symbol_a.value;
					final Symbol r = _symbols[offset + 8];
					final Symbol _symbol_s = _symbols[offset + 9];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForNode(l, new JSVarNode(v, i), s1, new JSEmptyNode(s1), s2, a, r, s);
			}
			case 137: // IterationStatement_NoIf = FOR LPAREN.l VAR.v VariableDeclarationList_NoIn.i SEMICOLON.s1 Expression.c SEMICOLON.s2 RPAREN.r Statement_NoIf.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol v = _symbols[offset + 3];
					final Symbol _symbol_i = _symbols[offset + 4];
					final ArrayList _list_i = (ArrayList) _symbol_i.value;
					final JSNode[] i = _list_i == null ? new JSNode[0] : (JSNode[]) _list_i.toArray(new JSNode[_list_i.size()]);
					final Symbol s1 = _symbols[offset + 5];
					final Symbol _symbol_c = _symbols[offset + 6];
					final JSNode c = (JSNode) _symbol_c.value;
					final Symbol s2 = _symbols[offset + 7];
					final Symbol r = _symbols[offset + 8];
					final Symbol _symbol_s = _symbols[offset + 9];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForNode(l, new JSVarNode(v, i), s1, c, s2, new JSEmptyNode(s2), r, s);
			}
			case 138: // IterationStatement_NoIf = FOR LPAREN.l VAR.v VariableDeclarationList_NoIn.i SEMICOLON.s1 Expression.c SEMICOLON.s2 Expression.a RPAREN.r Statement_NoIf.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol v = _symbols[offset + 3];
					final Symbol _symbol_i = _symbols[offset + 4];
					final ArrayList _list_i = (ArrayList) _symbol_i.value;
					final JSNode[] i = _list_i == null ? new JSNode[0] : (JSNode[]) _list_i.toArray(new JSNode[_list_i.size()]);
					final Symbol s1 = _symbols[offset + 5];
					final Symbol _symbol_c = _symbols[offset + 6];
					final JSNode c = (JSNode) _symbol_c.value;
					final Symbol s2 = _symbols[offset + 7];
					final Symbol _symbol_a = _symbols[offset + 8];
					final JSNode a = (JSNode) _symbol_a.value;
					final Symbol r = _symbols[offset + 9];
					final Symbol _symbol_s = _symbols[offset + 10];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForNode(l, new JSVarNode(v, i), s1, c, s2, a, r, s);
			}
			case 139: // IterationStatement_NoIf = FOR LPAREN.l LeftHandSideExpression.i IN.in Expression.o RPAREN.r Statement_NoIf.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_i = _symbols[offset + 3];
					final JSNode i = (JSNode) _symbol_i.value;
					final Symbol in = _symbols[offset + 4];
					final Symbol _symbol_o = _symbols[offset + 5];
					final JSNode o = (JSNode) _symbol_o.value;
					final Symbol r = _symbols[offset + 6];
					final Symbol _symbol_s = _symbols[offset + 7];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForInNode(l, i, in, o, r, s);
			}
			case 140: // IterationStatement_NoIf = FOR LPAREN.l VAR.v VariableDeclaration_NoIn.i IN.in Expression.o RPAREN.r Statement_NoIf.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol v = _symbols[offset + 3];
					final Symbol _symbol_i = _symbols[offset + 4];
					final JSNode i = (JSNode) _symbol_i.value;
					final Symbol in = _symbols[offset + 5];
					final Symbol _symbol_o = _symbols[offset + 6];
					final JSNode o = (JSNode) _symbol_o.value;
					final Symbol r = _symbols[offset + 7];
					final Symbol _symbol_s = _symbols[offset + 8];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSForInNode(l, new JSVarNode(v, i), in, o, r, s);
			}
			case 141: // ContinueStatement = CONTINUE SEMICOLON
			{
					
			JSNode node = new JSContinueNode();
			node.setSemicolonIncluded(true);
			return node;
			}
			case 142: // ContinueStatement = CONTINUE Identifier.i SEMICOLON
			{
					final Symbol i = _symbols[offset + 2];
					
			JSNode node = new JSContinueNode(i);
			node.setSemicolonIncluded(true);
			return node;
			}
			case 143: // BreakStatement = BREAK SEMICOLON
			{
					
			JSNode node = new JSBreakNode();
			node.setSemicolonIncluded(true);
			return node;
			}
			case 144: // BreakStatement = BREAK Identifier.i SEMICOLON
			{
					final Symbol i = _symbols[offset + 2];
					
			JSNode node = new JSBreakNode(i);
			node.setSemicolonIncluded(true);
			return node;
			}
			case 145: // ReturnStatement = RETURN.r SEMICOLON
			{
					final Symbol r = _symbols[offset + 1];
					
			JSNode node = new JSReturnNode(new JSEmptyNode(r));
			node.setSemicolonIncluded(true);
			return node;
			}
			case 146: // ReturnStatement = RETURN Expression.e SEMICOLON
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					
			JSNode node = new JSReturnNode(e);
			node.setSemicolonIncluded(true);
			return node;
			}
			case 147: // WithStatement = WITH LPAREN.l Expression.e RPAREN.r Statement.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol r = _symbols[offset + 4];
					final Symbol _symbol_s = _symbols[offset + 5];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSWithNode(l, e, r, s);
			}
			case 148: // WithStatement_NoIf = WITH LPAREN.l Expression.e RPAREN.r Statement_NoIf.s
			{
					final Symbol l = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol r = _symbols[offset + 4];
					final Symbol _symbol_s = _symbols[offset + 5];
					final JSNode s = (JSNode) _symbol_s.value;
					
			return new JSWithNode(l, e, r, s);
			}
			case 149: // SwitchStatement = SWITCH LPAREN.lp Expression.e RPAREN.rp LCURLY.lc RCURLY.rc
			{
					final Symbol lp = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol rp = _symbols[offset + 4];
					final Symbol lc = _symbols[offset + 5];
					final Symbol rc = _symbols[offset + 6];
					
			return new JSSwitchNode(lp, e, rp, lc, rc);
			}
			case 150: // SwitchStatement = SWITCH LPAREN.lp Expression.e RPAREN.rp LCURLY.lc CaseClauses.c RCURLY.rc
			{
					final Symbol lp = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol rp = _symbols[offset + 4];
					final Symbol lc = _symbols[offset + 5];
					final Symbol _symbol_c = _symbols[offset + 6];
					final ArrayList _list_c = (ArrayList) _symbol_c.value;
					final JSNode[] c = _list_c == null ? new JSNode[0] : (JSNode[]) _list_c.toArray(new JSNode[_list_c.size()]);
					final Symbol rc = _symbols[offset + 7];
					
			List<JSNode> nodes = new ArrayList<JSNode>();

			for (JSNode statement : c)
			{
				nodes.add(statement);
			}

			JSNode[] children = nodes.toArray(new JSNode[nodes.size()]);

			return new JSSwitchNode(lp, e, rp, lc, rc, children);
			}
			case 151: // SwitchStatement = SWITCH LPAREN.lp Expression.e RPAREN.rp LCURLY.lc DefaultClause.d RCURLY.rc
			{
					final Symbol lp = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol rp = _symbols[offset + 4];
					final Symbol lc = _symbols[offset + 5];
					final Symbol _symbol_d = _symbols[offset + 6];
					final JSNode d = (JSNode) _symbol_d.value;
					final Symbol rc = _symbols[offset + 7];
					
			return new JSSwitchNode(lp, e, rp, lc, rc, d);
			}
			case 152: // SwitchStatement = SWITCH LPAREN.lp Expression.e RPAREN.rp LCURLY.lc DefaultClause.d CaseClauses.c RCURLY.rc
			{
					final Symbol lp = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol rp = _symbols[offset + 4];
					final Symbol lc = _symbols[offset + 5];
					final Symbol _symbol_d = _symbols[offset + 6];
					final JSNode d = (JSNode) _symbol_d.value;
					final Symbol _symbol_c = _symbols[offset + 7];
					final ArrayList _list_c = (ArrayList) _symbol_c.value;
					final JSNode[] c = _list_c == null ? new JSNode[0] : (JSNode[]) _list_c.toArray(new JSNode[_list_c.size()]);
					final Symbol rc = _symbols[offset + 8];
					
			List<JSNode> nodes = new ArrayList<JSNode>();

			nodes.add(d);

			for (JSNode statement : c)
			{
				nodes.add(statement);
			}

			JSNode[] children = nodes.toArray(new JSNode[nodes.size()]);

			return new JSSwitchNode(lp, e, rp, lc, rc, children);
			}
			case 153: // SwitchStatement = SWITCH LPAREN.lp Expression.e RPAREN.rp LCURLY.lc CaseClauses.c DefaultClause.d RCURLY.rc
			{
					final Symbol lp = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol rp = _symbols[offset + 4];
					final Symbol lc = _symbols[offset + 5];
					final Symbol _symbol_c = _symbols[offset + 6];
					final ArrayList _list_c = (ArrayList) _symbol_c.value;
					final JSNode[] c = _list_c == null ? new JSNode[0] : (JSNode[]) _list_c.toArray(new JSNode[_list_c.size()]);
					final Symbol _symbol_d = _symbols[offset + 7];
					final JSNode d = (JSNode) _symbol_d.value;
					final Symbol rc = _symbols[offset + 8];
					
			List<JSNode> nodes = new ArrayList<JSNode>();

			for (JSNode statement : c)
			{
				nodes.add(statement);
			}

			nodes.add(d);

			JSNode[] children = nodes.toArray(new JSNode[nodes.size()]);

			return new JSSwitchNode(lp, e, rp, lc, rc, children);
			}
			case 154: // SwitchStatement = SWITCH LPAREN.lp Expression.e RPAREN.rp LCURLY.lc CaseClauses.c1 DefaultClause.d CaseClauses.c2 RCURLY.rc
			{
					final Symbol lp = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol rp = _symbols[offset + 4];
					final Symbol lc = _symbols[offset + 5];
					final Symbol _symbol_c1 = _symbols[offset + 6];
					final ArrayList _list_c1 = (ArrayList) _symbol_c1.value;
					final JSNode[] c1 = _list_c1 == null ? new JSNode[0] : (JSNode[]) _list_c1.toArray(new JSNode[_list_c1.size()]);
					final Symbol _symbol_d = _symbols[offset + 7];
					final JSNode d = (JSNode) _symbol_d.value;
					final Symbol _symbol_c2 = _symbols[offset + 8];
					final ArrayList _list_c2 = (ArrayList) _symbol_c2.value;
					final JSNode[] c2 = _list_c2 == null ? new JSNode[0] : (JSNode[]) _list_c2.toArray(new JSNode[_list_c2.size()]);
					final Symbol rc = _symbols[offset + 9];
					
			List<JSNode> nodes = new ArrayList<JSNode>();

			for (JSNode statement : c1)
			{
				nodes.add(statement);
			}

			nodes.add(d);

			for (JSNode statement : c2)
			{
				nodes.add(statement);
			}

			JSNode[] children = nodes.toArray(new JSNode[nodes.size()]);

			return new JSSwitchNode(lp, e, rp, lc, rc, children);
			}
			case 155: // CaseClauses = CaseClauses CaseClause
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
			}
			case 156: // CaseClauses = CaseClause
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 157: // CaseClause = CASE Expression.e COLON.c
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol c = _symbols[offset + 3];
					
			return new JSCaseNode(e, c);
			}
			case 158: // CaseClause = CASE Expression.e COLON.c StatementList.s
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol c = _symbols[offset + 3];
					final Symbol _symbol_s = _symbols[offset + 4];
					final ArrayList _list_s = (ArrayList) _symbol_s.value;
					final JSNode[] s = _list_s == null ? new JSNode[0] : (JSNode[]) _list_s.toArray(new JSNode[_list_s.size()]);
					
			return new JSCaseNode(e, c, s);
			}
			case 159: // DefaultClause = DEFAULT COLON.c
			{
					final Symbol c = _symbols[offset + 2];
					
			return new JSDefaultNode(c);
			}
			case 160: // DefaultClause = DEFAULT COLON.c StatementList.s
			{
					final Symbol c = _symbols[offset + 2];
					final Symbol _symbol_s = _symbols[offset + 3];
					final ArrayList _list_s = (ArrayList) _symbol_s.value;
					final JSNode[] s = _list_s == null ? new JSNode[0] : (JSNode[]) _list_s.toArray(new JSNode[_list_s.size()]);
					
			return new JSDefaultNode(c, s);
			}
			case 161: // LabelledStatement = Identifier.i COLON.c Statement.s
			{
					final Symbol i = _symbols[offset + 1];
					final Symbol c = _symbols[offset + 2];
					final Symbol _symbol_s = _symbols[offset + 3];
					final JSNode s = (JSNode) _symbol_s.value;
					
			JSNode id = new JSIdentifierNode(i);
			id.setLocation(i.getStart(), i.getEnd());

			return new JSLabelledNode(id, c, s);
			}
			case 162: // LabelledStatement_NoIf = Identifier.i COLON.c Statement_NoIf.s
			{
					final Symbol i = _symbols[offset + 1];
					final Symbol c = _symbols[offset + 2];
					final Symbol _symbol_s = _symbols[offset + 3];
					final JSNode s = (JSNode) _symbol_s.value;
					
			JSNode id = new JSIdentifierNode(i);
			id.setLocation(i.getStart(), i.getEnd());

			return new JSLabelledNode(id, c, s);
			}
			case 163: // ThrowStatement = THROW Expression.e SEMICOLON
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					
			JSNode node = new JSThrowNode(e);

			node.setSemicolonIncluded(true);

			return node;
			}
			case 164: // TryStatement = TRY Block.b Catch.c
			{
					final Symbol _symbol_b = _symbols[offset + 2];
					final JSNode b = (JSNode) _symbol_b.value;
					final Symbol _symbol_c = _symbols[offset + 3];
					final JSNode c = (JSNode) _symbol_c.value;
					
			return new JSTryNode(b, c, new JSEmptyNode(c));
			}
			case 165: // TryStatement = TRY Block.b Finally.f
			{
					final Symbol _symbol_b = _symbols[offset + 2];
					final JSNode b = (JSNode) _symbol_b.value;
					final Symbol _symbol_f = _symbols[offset + 3];
					final JSNode f = (JSNode) _symbol_f.value;
					
			return new JSTryNode(b, new JSEmptyNode(b), f);
			}
			case 166: // TryStatement = TRY Block.b Catch.c Finally.f
			{
					final Symbol _symbol_b = _symbols[offset + 2];
					final JSNode b = (JSNode) _symbol_b.value;
					final Symbol _symbol_c = _symbols[offset + 3];
					final JSNode c = (JSNode) _symbol_c.value;
					final Symbol _symbol_f = _symbols[offset + 4];
					final JSNode f = (JSNode) _symbol_f.value;
					
			return new JSTryNode(b, c, f);
			}
			case 167: // Catch = CATCH LPAREN Identifier.i RPAREN Block.b
			{
					final Symbol i = _symbols[offset + 3];
					final Symbol _symbol_b = _symbols[offset + 5];
					final JSNode b = (JSNode) _symbol_b.value;
					
			JSNode id = new JSIdentifierNode(i);

			return new JSCatchNode(id, b);
			}
			case 168: // Finally = FINALLY Block.b
			{
					final Symbol _symbol_b = _symbols[offset + 2];
					final JSNode b = (JSNode) _symbol_b.value;
					
			return new JSFinallyNode(b);
			}
			case 171: // PrimaryExpression_NoLBF = THIS.t
			{
					final Symbol t = _symbols[offset + 1];
					
			return new JSThisNode(t);
			}
			case 172: // PrimaryExpression_NoLBF = Identifier.i
			{
					final Symbol i = _symbols[offset + 1];
					
			return new JSIdentifierNode(i);
			}
			case 175: // PrimaryExpression_NoLBF = LPAREN.l Expression.e RPAREN.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol r = _symbols[offset + 3];
					
			return new JSGroupNode(l, e, r);
			}
			case 176: // ArrayLiteral = LBRACKET.l RBRACKET.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol r = _symbols[offset + 2];
					
			return new JSArrayNode(l, r);
			}
			case 177: // ArrayLiteral = LBRACKET.l Elision.e RBRACKET.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol r = _symbols[offset + 3];
					
			e.addChild(new JSNullNode());
			return new JSArrayNode(l, r, e);
			}
			case 178: // ArrayLiteral = LBRACKET.l ElementList.e RBRACKET.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol r = _symbols[offset + 3];
					
			return new JSArrayNode(l, r, e);
			}
			case 179: // ArrayLiteral = LBRACKET.l ElementList.e COMMA RBRACKET.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol r = _symbols[offset + 4];
					
			return new JSArrayNode(l, r, e, new JSNullNode());
			}
			case 180: // ArrayLiteral = LBRACKET.l ElementList.e COMMA Elision.n RBRACKET.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol _symbol_n = _symbols[offset + 4];
					final JSNode n = (JSNode) _symbol_n.value;
					final Symbol r = _symbols[offset + 5];
					
			n.addChild(new JSNullNode());
			return new JSArrayNode(l, r, e, n);
			}
			case 181: // ElementList = AssignmentExpression.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final JSNode e = (JSNode) _symbol_e.value;
					
			return new JSElementsNode(e);
			}
			case 182: // ElementList = Elision.n AssignmentExpression.e
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final JSNode n = (JSNode) _symbol_n.value;
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					
			return new JSElementsNode(n, e);
			}
			case 183: // ElementList = ElementList.l COMMA AssignmentExpression.e
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_e = _symbols[offset + 3];
					final JSNode e = (JSNode) _symbol_e.value;
					
			l.addChild(e);

			return l;
			}
			case 184: // ElementList = ElementList.l COMMA Elision.n AssignmentExpression.e
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_n = _symbols[offset + 3];
					final JSNode n = (JSNode) _symbol_n.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final JSNode e = (JSNode) _symbol_e.value;
					
			l.addChild(n);
			l.addChild(e);

			return l;
			}
			case 185: // Elision = Elision.e COMMA
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final JSNode e = (JSNode) _symbol_e.value;
					
			e.addChild(new JSNullNode());

			return e;
			}
			case 186: // Elision = COMMA
			{
					
			return new JSElisionNode(new JSNullNode());
			}
			case 187: // ObjectLiteral = LCURLY.l RCURLY.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol r = _symbols[offset + 2];
					
			return new JSObjectNode(l, r);
			}
			case 188: // ObjectLiteral = LCURLY.l PropertyNameAndValueList.p RCURLY.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_p = _symbols[offset + 2];
					final ArrayList _list_p = (ArrayList) _symbol_p.value;
					final JSNode[] p = _list_p == null ? new JSNode[0] : (JSNode[]) _list_p.toArray(new JSNode[_list_p.size()]);
					final Symbol r = _symbols[offset + 3];
					
			return new JSObjectNode(l, r, p);
			}
			case 189: // ObjectLiteral = LCURLY.l PropertyNameAndValueList.p COMMA RCURLY.r
			{
					final Symbol l = _symbols[offset + 1];
					final Symbol _symbol_p = _symbols[offset + 2];
					final ArrayList _list_p = (ArrayList) _symbol_p.value;
					final JSNode[] p = _list_p == null ? new JSNode[0] : (JSNode[]) _list_p.toArray(new JSNode[_list_p.size()]);
					final Symbol r = _symbols[offset + 4];
					
			return new JSObjectNode(l, r, p);
			}
			case 190: // PropertyNameAndValueList = PropertyAssignment
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 191: // PropertyNameAndValueList = PropertyNameAndValueList COMMA PropertyAssignment
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
			}
			case 192: // PropertyAssignment = PropertyName.n COLON.c AssignmentExpression.v
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final JSNode n = (JSNode) _symbol_n.value;
					final Symbol c = _symbols[offset + 2];
					final Symbol _symbol_v = _symbols[offset + 3];
					final JSNode v = (JSNode) _symbol_v.value;
					
			return new JSNameValuePairNode(n, c, v);
			}
			case 193: // PropertyAssignment = GET PropertyName.n LPAREN RPAREN FunctionBody.body
			{
					final Symbol _symbol_n = _symbols[offset + 2];
					final JSNode n = (JSNode) _symbol_n.value;
					final Symbol _symbol_body = _symbols[offset + 5];
					final JSNode body = (JSNode) _symbol_body.value;
					
			return new JSNameValuePairNode(n, body);
			}
			case 194: // PropertyAssignment = SET PropertyName.n LPAREN PropertySetParameterList.p RPAREN FunctionBody.body
			{
					final Symbol _symbol_n = _symbols[offset + 2];
					final JSNode n = (JSNode) _symbol_n.value;
					final Symbol p = _symbols[offset + 4];
					final Symbol _symbol_body = _symbols[offset + 6];
					final JSNode body = (JSNode) _symbol_body.value;
					
			JSIdentifierNode ident = new JSIdentifierNode(p);
			JSParametersNode params = new JSParametersNode(ident);
			params.setLocation(ident.getStartingOffset(), ident.getEndingOffset());
			return new JSNameValuePairNode(n, params, body);
			}
			case 195: // PropertyName = IdentifierName.i
			{
					final Symbol i = _symbols[offset + 1];
					
			return new JSIdentifierNode(i);
			}
			case 196: // PropertyName = STRING.s
			{
					final Symbol s = _symbols[offset + 1];
					
			return new JSStringNode(s);
			}
			case 197: // PropertyName = NUMBER.n
			{
					final Symbol n = _symbols[offset + 1];
					
			return new JSNumberNode(n);
			}
			case 201: // MemberExpression = MemberExpression.l LBRACKET.lb Expression.r RBRACKET.rb
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol lb = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					final Symbol rb = _symbols[offset + 4];
					
			return new JSGetElementNode(l, lb, r, rb);
			}
			case 202: // MemberExpression = MemberExpression.l DOT.o IdentifierName.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol r = _symbols[offset + 3];
					
			return new JSGetPropertyNode(l, o, new JSIdentifierNode(r));
			}
			case 203: // MemberExpression = NEW MemberExpression.e Arguments.a
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol _symbol_a = _symbols[offset + 3];
					final JSArgumentsNode a = (JSArgumentsNode) _symbol_a.value;
					
			return new JSConstructNode(e, a);
			}
			case 205: // MemberExpression_NoLBF = MemberExpression_NoLBF.l LBRACKET.lb Expression.r RBRACKET.rb
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol lb = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					final Symbol rb = _symbols[offset + 4];
					
			return new JSGetElementNode(l, lb, r, rb);
			}
			case 206: // MemberExpression_NoLBF = MemberExpression_NoLBF.l DOT.o IdentifierName.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol r = _symbols[offset + 3];
					
			return new JSGetPropertyNode(l, o, new JSIdentifierNode(r));
			}
			case 207: // MemberExpression_NoLBF = NEW MemberExpression.e Arguments.a
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol _symbol_a = _symbols[offset + 3];
					final JSArgumentsNode a = (JSArgumentsNode) _symbol_a.value;
					
			return new JSConstructNode(e, a);
			}
			case 209: // NewExpression = NEW NewExpression.e
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					
			return new JSConstructNode(e, new JSEmptyNode(e));
			}
			case 211: // NewExpression_NoLBF = NEW NewExpression.e
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					
			return new JSConstructNode(e, new JSEmptyNode(e));
			}
			case 212: // CallExpression = MemberExpression.l Arguments.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 2];
					final JSArgumentsNode r = (JSArgumentsNode) _symbol_r.value;
					
			return new JSInvokeNode(l, r);
			}
			case 213: // CallExpression = CallExpression.l Arguments.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 2];
					final JSArgumentsNode r = (JSArgumentsNode) _symbol_r.value;
					
			return new JSInvokeNode(l, r);
			}
			case 214: // CallExpression = CallExpression.l LBRACKET.lb Expression.r RBRACKET.rb
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol lb = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					final Symbol rb = _symbols[offset + 4];
					
			return new JSGetElementNode(l, lb, r, rb);
			}
			case 215: // CallExpression = CallExpression.l DOT.o IdentifierName.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol r = _symbols[offset + 3];
					
			return new JSGetPropertyNode(l, o, new JSIdentifierNode(r));
			}
			case 216: // CallExpression_NoLBF = MemberExpression_NoLBF.l Arguments.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 2];
					final JSArgumentsNode r = (JSArgumentsNode) _symbol_r.value;
					
			return new JSInvokeNode(l, r);
			}
			case 217: // CallExpression_NoLBF = CallExpression_NoLBF.l Arguments.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 2];
					final JSArgumentsNode r = (JSArgumentsNode) _symbol_r.value;
					
			return new JSInvokeNode(l, r);
			}
			case 218: // CallExpression_NoLBF = CallExpression_NoLBF.l LBRACKET.lb Expression.r RBRACKET.rb
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol lb = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					final Symbol rb = _symbols[offset + 4];
					
			return new JSGetElementNode(l, lb, r, rb);
			}
			case 219: // CallExpression_NoLBF = CallExpression_NoLBF.l DOT.o IdentifierName.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol r = _symbols[offset + 3];
					
			return new JSGetPropertyNode(l, o, new JSIdentifierNode(r));
			}
			case 220: // Arguments = LPAREN RPAREN
			{
					
			return new JSArgumentsNode();
			}
			case 221: // Arguments = LPAREN ArgumentList.a RPAREN
			{
					final Symbol _symbol_a = _symbols[offset + 2];
					final ArrayList _list_a = (ArrayList) _symbol_a.value;
					final JSNode[] a = _list_a == null ? new JSNode[0] : (JSNode[]) _list_a.toArray(new JSNode[_list_a.size()]);
					
			return new JSArgumentsNode(a);
			}
			case 222: // ArgumentList = ArgumentList COMMA AssignmentExpression
			{
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
			}
			case 223: // ArgumentList = AssignmentExpression
			{
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
			}
			case 229: // PostfixExpression = LeftHandSideExpression.e PostfixOperator.o
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol o = _symbols[offset + 2];
					
			return new JSPostUnaryOperatorNode(o, e);
			}
			case 231: // PostfixExpression_NoLBF = LeftHandSideExpression_NoLBF.e PostfixOperator.o
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final JSNode e = (JSNode) _symbol_e.value;
					final Symbol o = _symbols[offset + 2];
					
			return new JSPostUnaryOperatorNode(o, e);
			}
			case 235: // UnaryExpression = UnaryOperator.o UnaryExpression.e
			{
					final Symbol o = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					
			return new JSPreUnaryOperatorNode(o, e);
			}
			case 237: // UnaryExpression_NoLBF = UnaryOperator.o UnaryExpression.e
			{
					final Symbol o = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final JSNode e = (JSNode) _symbol_e.value;
					
			return new JSPreUnaryOperatorNode(o, e);
			}
			case 248: // MultiplicativeExpression = MultiplicativeExpression.l MultiplicativeOperator.o UnaryExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryArithmeticOperatorNode(l, o, r);
			}
			case 250: // MultiplicativeExpression_NoLBF = MultiplicativeExpression_NoLBF.l MultiplicativeOperator.o UnaryExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryArithmeticOperatorNode(l, o, r);
			}
			case 255: // AdditiveExpression = AdditiveExpression.l AdditiveOperator.o MultiplicativeExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryArithmeticOperatorNode(l, o, r);
			}
			case 257: // AdditiveExpression_NoLBF = AdditiveExpression_NoLBF.l AdditiveOperator.o MultiplicativeExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryArithmeticOperatorNode(l, o, r);
			}
			case 261: // ShiftExpression = ShiftExpression.l ShiftOperator.o AdditiveExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryArithmeticOperatorNode(l, o, r);
			}
			case 263: // ShiftExpression_NoLBF = ShiftExpression_NoLBF.l ShiftOperator.o AdditiveExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryArithmeticOperatorNode(l, o, r);
			}
			case 268: // RelationalExpression = RelationalExpression.l RelationalOperator.o ShiftExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryBooleanOperatorNode(l, o, r);
			}
			case 270: // RelationalExpression_NoLBF = RelationalExpression_NoLBF.l RelationalOperator.o ShiftExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryBooleanOperatorNode(l, o, r);
			}
			case 272: // RelationalExpression_NoIn = RelationalExpression_NoIn.l RelationalOperator_NoIn.o ShiftExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryBooleanOperatorNode(l, o, r);
			}
			case 281: // EqualityExpression = EqualityExpression.l EqualityOperator.o RelationalExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryBooleanOperatorNode(l, o, r);
			}
			case 283: // EqualityExpression_NoLBF = EqualityExpression_NoLBF.l EqualityOperator.o RelationalExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryBooleanOperatorNode(l, o, r);
			}
			case 285: // EqualityExpression_NoIn = EqualityExpression_NoIn.l EqualityOperator.o RelationalExpression_NoIn.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryBooleanOperatorNode(l, o, r);
			}
			case 290: // BitwiseAndExpression = BitwiseAndExpression.l AMPERSAND.o EqualityExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryArithmeticOperatorNode(l, o, r);
			}
			case 292: // BitwiseAndExpression_NoLBF = BitwiseAndExpression_NoLBF.l AMPERSAND.o EqualityExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryArithmeticOperatorNode(l, o, r);
			}
			case 294: // BitwiseAndExpression_NoIn = BitwiseAndExpression_NoIn.l AMPERSAND.o EqualityExpression_NoIn.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryArithmeticOperatorNode(l, o, r);
			}
			case 296: // BitwiseXorExpression = BitwiseXorExpression.l CARET.o BitwiseAndExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryArithmeticOperatorNode(l, o, r);
			}
			case 298: // BitwiseXorExpression_NoLBF = BitwiseXorExpression_NoLBF.l CARET.o BitwiseAndExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryArithmeticOperatorNode(l, o, r);
			}
			case 300: // BitwiseXorExpression_NoIn = BitwiseXorExpression_NoIn.l CARET.o BitwiseAndExpression_NoIn.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryArithmeticOperatorNode(l, o, r);
			}
			case 302: // BitwiseOrExpression = BitwiseOrExpression.l PIPE.o BitwiseXorExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryArithmeticOperatorNode(l, o, r);
			}
			case 304: // BitwiseOrExpression_NoLBF = BitwiseOrExpression_NoLBF.l PIPE.o BitwiseXorExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryArithmeticOperatorNode(l, o, r);
			}
			case 306: // BitwiseOrExpression_NoIn = BitwiseOrExpression_NoIn.l PIPE.o BitwiseXorExpression_NoIn.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryArithmeticOperatorNode(l, o, r);
			}
			case 308: // LogicalAndExpression = LogicalAndExpression.l AMPERSAND_AMPERSAND.o BitwiseOrExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryBooleanOperatorNode(l, o, r);
			}
			case 310: // LogicalAndExpression_NoLBF = LogicalAndExpression_NoLBF.l AMPERSAND_AMPERSAND.o BitwiseOrExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryBooleanOperatorNode(l, o, r);
			}
			case 312: // LogicalAndExpression_NoIn = LogicalAndExpression_NoIn.l AMPERSAND_AMPERSAND.o BitwiseOrExpression_NoIn.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryBooleanOperatorNode(l, o, r);
			}
			case 314: // LogicalOrExpression = LogicalOrExpression.l PIPE_PIPE.o LogicalAndExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryBooleanOperatorNode(l, o, r);
			}
			case 316: // LogicalOrExpression_NoLBF = LogicalOrExpression_NoLBF.l PIPE_PIPE.o LogicalAndExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryBooleanOperatorNode(l, o, r);
			}
			case 318: // LogicalOrExpression_NoIn = LogicalOrExpression_NoIn.l PIPE_PIPE.o LogicalAndExpression_NoIn.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSBinaryBooleanOperatorNode(l, o, r);
			}
			case 321: // ConditionalExpression = LogicalOrExpression.l QUESTION.q AssignmentExpression.t COLON.c AssignmentExpression.f
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol q = _symbols[offset + 2];
					final Symbol _symbol_t = _symbols[offset + 3];
					final JSNode t = (JSNode) _symbol_t.value;
					final Symbol c = _symbols[offset + 4];
					final Symbol _symbol_f = _symbols[offset + 5];
					final JSNode f = (JSNode) _symbol_f.value;
					
			return new JSConditionalNode(l, q, t, c, f);
			}
			case 323: // ConditionalExpression_NoLBF = LogicalOrExpression_NoLBF.l QUESTION.q AssignmentExpression.t COLON.c AssignmentExpression.f
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol q = _symbols[offset + 2];
					final Symbol _symbol_t = _symbols[offset + 3];
					final JSNode t = (JSNode) _symbol_t.value;
					final Symbol c = _symbols[offset + 4];
					final Symbol _symbol_f = _symbols[offset + 5];
					final JSNode f = (JSNode) _symbol_f.value;
					
			return new JSConditionalNode(l, q, t, c, f);
			}
			case 325: // ConditionalExpression_NoIn = LogicalOrExpression_NoIn.l QUESTION.q AssignmentExpression_NoIn.t COLON.c AssignmentExpression_NoIn.f
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol q = _symbols[offset + 2];
					final Symbol _symbol_t = _symbols[offset + 3];
					final JSNode t = (JSNode) _symbol_t.value;
					final Symbol c = _symbols[offset + 4];
					final Symbol _symbol_f = _symbols[offset + 5];
					final JSNode f = (JSNode) _symbol_f.value;
					
			return new JSConditionalNode(l, q, t, c, f);
			}
			case 327: // AssignmentExpression = LeftHandSideExpression.l AssignmentOperator.o AssignmentExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSAssignmentNode(l, o, r);
			}
			case 329: // AssignmentExpression_NoLBF = LeftHandSideExpression_NoLBF.l AssignmentOperator.o AssignmentExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSAssignmentNode(l, o, r);
			}
			case 331: // AssignmentExpression_NoIn = LeftHandSideExpression.l AssignmentOperator.o AssignmentExpression_NoIn.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol o = _symbols[offset + 2];
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSAssignmentNode(l, o, r);
			}
			case 344: // Expression = Expression.l COMMA AssignmentExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSCommaNode(l, r);
			}
			case 346: // Expression_NoLBF = Expression_NoLBF.l COMMA AssignmentExpression.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSCommaNode(l, r);
			}
			case 348: // Expression_NoIn = Expression_NoIn.l COMMA AssignmentExpression_NoIn.r
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final JSNode l = (JSNode) _symbol_l.value;
					final Symbol _symbol_r = _symbols[offset + 3];
					final JSNode r = (JSNode) _symbol_r.value;
					
			return new JSCommaNode(l, r);
			}
			case 350: // Literal = NULL.n
			{
					final Symbol n = _symbols[offset + 1];
					
			return new JSNullNode(n);
			}
			case 351: // Literal = TRUE.t
			{
					final Symbol t = _symbols[offset + 1];
					
			return new JSTrueNode(t);
			}
			case 352: // Literal = FALSE.f
			{
					final Symbol f = _symbols[offset + 1];
					
			return new JSFalseNode(f);
			}
			case 353: // Literal = NUMBER.n
			{
					final Symbol n = _symbols[offset + 1];
					
			return new JSNumberNode(n);
			}
			case 354: // Literal = STRING.s
			{
					final Symbol s = _symbols[offset + 1];
					
			return new JSStringNode(s);
			}
			case 355: // Literal = REGEX.r
			{
					final Symbol r = _symbols[offset + 1];
					
			return new JSRegexNode(r);
			}
			case 4: // SourceElement = Statement
			case 6: // Identifier = IDENTIFIER
			case 7: // Identifier = GET
			case 8: // Identifier = SET
			case 9: // IdentifierName = Identifier
			case 10: // IdentifierName = BREAK
			case 11: // IdentifierName = CASE
			case 12: // IdentifierName = CATCH
			case 13: // IdentifierName = CONTINUE
			case 14: // IdentifierName = DEBUGGER
			case 15: // IdentifierName = DEFAULT
			case 16: // IdentifierName = DELETE
			case 17: // IdentifierName = DO
			case 18: // IdentifierName = ELSE
			case 19: // IdentifierName = FALSE
			case 20: // IdentifierName = FINALLY
			case 21: // IdentifierName = FOR
			case 22: // IdentifierName = FUNCTION
			case 23: // IdentifierName = IF
			case 24: // IdentifierName = INSTANCEOF
			case 25: // IdentifierName = IN
			case 26: // IdentifierName = NEW
			case 27: // IdentifierName = NULL
			case 28: // IdentifierName = RETURN
			case 29: // IdentifierName = SWITCH
			case 30: // IdentifierName = THIS
			case 31: // IdentifierName = THROW
			case 32: // IdentifierName = TRUE
			case 33: // IdentifierName = TRY
			case 34: // IdentifierName = TYPEOF
			case 35: // IdentifierName = VAR
			case 36: // IdentifierName = VOID
			case 37: // IdentifierName = WHILE
			case 38: // IdentifierName = WITH
			case 39: // IdentifierName = CLASS
			case 40: // IdentifierName = ENUM
			case 41: // IdentifierName = EXPORT
			case 42: // IdentifierName = EXTENDS
			case 43: // IdentifierName = IMPORT
			case 44: // IdentifierName = SUPER
			case 45: // IdentifierName = IMPLEMENTS
			case 46: // IdentifierName = INTERFACE
			case 47: // IdentifierName = LET
			case 48: // IdentifierName = PACKAGE
			case 49: // IdentifierName = PRIVATE
			case 50: // IdentifierName = PROTECTED
			case 51: // IdentifierName = PUBLIC
			case 52: // IdentifierName = STATIC
			case 53: // IdentifierName = YIELD
			case 55: // FunctionExpression = FunctionDeclaration
			case 62: // Statement = Block
			case 63: // Statement = FunctionDeclaration
			case 66: // Statement = IfStatement
			case 67: // Statement = IterationStatement
			case 68: // Statement = ContinueStatement
			case 69: // Statement = BreakStatement
			case 70: // Statement = ReturnStatement
			case 71: // Statement = WithStatement
			case 72: // Statement = LabelledStatement
			case 73: // Statement = SwitchStatement
			case 74: // Statement = ThrowStatement
			case 75: // Statement = TryStatement
			case 78: // Statement_NoIf = Block
			case 79: // Statement_NoIf = FunctionDeclaration
			case 82: // Statement_NoIf = IfStatement_NoIf
			case 83: // Statement_NoIf = IterationStatement_NoIf
			case 84: // Statement_NoIf = ContinueStatement
			case 85: // Statement_NoIf = BreakStatement
			case 86: // Statement_NoIf = ReturnStatement
			case 87: // Statement_NoIf = WithStatement_NoIf
			case 88: // Statement_NoIf = LabelledStatement_NoIf
			case 89: // Statement_NoIf = SwitchStatement
			case 90: // Statement_NoIf = ThrowStatement
			case 91: // Statement_NoIf = TryStatement
			case 169: // PrimaryExpression = PrimaryExpression_NoLBF
			case 170: // PrimaryExpression = ObjectLiteral
			case 173: // PrimaryExpression_NoLBF = Literal
			case 174: // PrimaryExpression_NoLBF = ArrayLiteral
			case 198: // PropertySetParameterList = Identifier
			case 199: // MemberExpression = PrimaryExpression
			case 200: // MemberExpression = FunctionExpression
			case 204: // MemberExpression_NoLBF = PrimaryExpression_NoLBF
			case 208: // NewExpression = MemberExpression
			case 210: // NewExpression_NoLBF = MemberExpression_NoLBF
			case 224: // LeftHandSideExpression = NewExpression
			case 225: // LeftHandSideExpression = CallExpression
			case 226: // LeftHandSideExpression_NoLBF = NewExpression_NoLBF
			case 227: // LeftHandSideExpression_NoLBF = CallExpression_NoLBF
			case 228: // PostfixExpression = LeftHandSideExpression
			case 230: // PostfixExpression_NoLBF = LeftHandSideExpression_NoLBF
			case 232: // PostfixOperator = PLUS_PLUS
			case 233: // PostfixOperator = MINUS_MINUS
			case 234: // UnaryExpression = PostfixExpression
			case 236: // UnaryExpression_NoLBF = PostfixExpression_NoLBF
			case 238: // UnaryOperator = DELETE
			case 239: // UnaryOperator = EXCLAMATION
			case 240: // UnaryOperator = MINUS
			case 241: // UnaryOperator = MINUS_MINUS
			case 242: // UnaryOperator = PLUS
			case 243: // UnaryOperator = PLUS_PLUS
			case 244: // UnaryOperator = TILDE
			case 245: // UnaryOperator = TYPEOF
			case 246: // UnaryOperator = VOID
			case 247: // MultiplicativeExpression = UnaryExpression
			case 249: // MultiplicativeExpression_NoLBF = UnaryExpression_NoLBF
			case 251: // MultiplicativeOperator = STAR
			case 252: // MultiplicativeOperator = FORWARD_SLASH
			case 253: // MultiplicativeOperator = PERCENT
			case 254: // AdditiveExpression = MultiplicativeExpression
			case 256: // AdditiveExpression_NoLBF = MultiplicativeExpression_NoLBF
			case 258: // AdditiveOperator = PLUS
			case 259: // AdditiveOperator = MINUS
			case 260: // ShiftExpression = AdditiveExpression
			case 262: // ShiftExpression_NoLBF = AdditiveExpression_NoLBF
			case 264: // ShiftOperator = LESS_LESS
			case 265: // ShiftOperator = GREATER_GREATER
			case 266: // ShiftOperator = GREATER_GREATER_GREATER
			case 267: // RelationalExpression = ShiftExpression
			case 269: // RelationalExpression_NoLBF = ShiftExpression_NoLBF
			case 271: // RelationalExpression_NoIn = ShiftExpression
			case 273: // RelationalOperator_NoIn = LESS
			case 274: // RelationalOperator_NoIn = GREATER
			case 275: // RelationalOperator_NoIn = LESS_EQUAL
			case 276: // RelationalOperator_NoIn = GREATER_EQUAL
			case 277: // RelationalOperator_NoIn = INSTANCEOF
			case 278: // RelationalOperator = RelationalOperator_NoIn
			case 279: // RelationalOperator = IN
			case 280: // EqualityExpression = RelationalExpression
			case 282: // EqualityExpression_NoLBF = RelationalExpression_NoLBF
			case 284: // EqualityExpression_NoIn = RelationalExpression_NoIn
			case 286: // EqualityOperator = EQUAL_EQUAL
			case 287: // EqualityOperator = EXCLAMATION_EQUAL
			case 288: // EqualityOperator = EQUAL_EQUAL_EQUAL
			case 289: // EqualityOperator = EXCLAMATION_EQUAL_EQUAL
			case 291: // BitwiseAndExpression = EqualityExpression
			case 293: // BitwiseAndExpression_NoLBF = EqualityExpression_NoLBF
			case 295: // BitwiseAndExpression_NoIn = EqualityExpression_NoIn
			case 297: // BitwiseXorExpression = BitwiseAndExpression
			case 299: // BitwiseXorExpression_NoLBF = BitwiseAndExpression_NoLBF
			case 301: // BitwiseXorExpression_NoIn = BitwiseAndExpression_NoIn
			case 303: // BitwiseOrExpression = BitwiseXorExpression
			case 305: // BitwiseOrExpression_NoLBF = BitwiseXorExpression_NoLBF
			case 307: // BitwiseOrExpression_NoIn = BitwiseXorExpression_NoIn
			case 309: // LogicalAndExpression = BitwiseOrExpression
			case 311: // LogicalAndExpression_NoLBF = BitwiseOrExpression_NoLBF
			case 313: // LogicalAndExpression_NoIn = BitwiseOrExpression_NoIn
			case 315: // LogicalOrExpression = LogicalAndExpression
			case 317: // LogicalOrExpression_NoLBF = LogicalAndExpression_NoLBF
			case 319: // LogicalOrExpression_NoIn = LogicalAndExpression_NoIn
			case 320: // ConditionalExpression = LogicalOrExpression
			case 322: // ConditionalExpression_NoLBF = LogicalOrExpression_NoLBF
			case 324: // ConditionalExpression_NoIn = LogicalOrExpression_NoIn
			case 326: // AssignmentExpression = ConditionalExpression
			case 328: // AssignmentExpression_NoLBF = ConditionalExpression_NoLBF
			case 330: // AssignmentExpression_NoIn = ConditionalExpression_NoIn
			case 332: // AssignmentOperator = EQUAL
			case 333: // AssignmentOperator = STAR_EQUAL
			case 334: // AssignmentOperator = FORWARD_SLASH_EQUAL
			case 335: // AssignmentOperator = PERCENT_EQUAL
			case 336: // AssignmentOperator = PLUS_EQUAL
			case 337: // AssignmentOperator = MINUS_EQUAL
			case 338: // AssignmentOperator = LESS_LESS_EQUAL
			case 339: // AssignmentOperator = GREATER_GREATER_EQUAL
			case 340: // AssignmentOperator = GREATER_GREATER_GREATER_EQUAL
			case 341: // AssignmentOperator = AMPERSAND_EQUAL
			case 342: // AssignmentOperator = CARET_EQUAL
			case 343: // AssignmentOperator = PIPE_EQUAL
			case 345: // Expression = AssignmentExpression
			case 347: // Expression_NoLBF = AssignmentExpression_NoLBF
			case 349: // Expression_NoIn = AssignmentExpression_NoIn
			{
				return _symbols[offset + 1];
			}
			default:
				throw new IllegalArgumentException("unknown production #" + rule_num);
		}
	}
}
