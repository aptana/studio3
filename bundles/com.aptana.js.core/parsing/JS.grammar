// java -jar beaver.jar -T -w JS.grammar
%package "com.aptana.js.core.parsing";

%class "JSParser";

%import "java.io.IOException";
%import "java.util.ArrayList";
%import "java.util.List";

%import "org.eclipse.core.runtime.Platform";

%import "com.aptana.core.build.IProblem";
%import "com.aptana.js.core.IJSConstants";
%import "com.aptana.js.core.JSCorePlugin";
%import "com.aptana.js.core.parsing.ast.*";
%import "com.aptana.js.core.preferences.IPreferenceConstants";
%import "com.aptana.parsing.IParseState";
%import "com.aptana.parsing.IParser";
%import "com.aptana.parsing.IRecoveryStrategy";
%import "com.aptana.parsing.ast.IParseNode";
%import "com.aptana.parsing.ast.IParseError";
%import "com.aptana.parsing.ast.ParseError";
%import "com.aptana.parsing.util.ParseUtil";
%import "com.aptana.parsing.WorkingParseResult";
%import "com.aptana.parsing.ParseResult";

%implements "IParser";

%embed {:
	private WorkingParseResult fWorking;

	// Collect the errors into a list of IParseErrors and let the custom error recovery mechanism handle it
	private class JSEvents extends Events
	{
		public void scannerError(Scanner.Exception e)
		{
		}

		public void syntaxError(Symbol token)
		{
			if (token != null && fWorking != null)
			{
				fWorking.addError(new ParseError(IJSConstants.CONTENT_TYPE_JS, token, IParseError.Severity.ERROR));
			}
		}

		public void unexpectedTokenRemoved(Symbol token)
		{
		}

		public void missingTokenInserted(Symbol token)
		{
		}

		public void missingTokensInserted(List<Symbol> tokens)
		{
			if (tokens != null && tokens.size() == 1 && tokens.get(0).getId() == Terminals.SEMICOLON)
			{
				// remove last error
				if (fWorking != null)
				{
					List<IParseError> errors = fWorking.getErrors();
					IParseError lastError = (errors.isEmpty()) ? null : errors.get(errors.size() - 1);

					if (lastError != null)
					{
						fWorking.removeError(lastError);
					}
				}
			}

			super.missingTokensInserted(tokens);
		}

		public void misspelledTokenReplaced(Symbol token)
		{
		}

		public void errorPhraseRemoved(Symbol error)
		{
		}
	}

	private final List<IRecoveryStrategy> recoveryStrategies;
	private JSFlexScanner fScanner;
	private IProblem.Severity fSemicolonSeverity = IProblem.Severity.WARNING;

    /**
     * attachPostDocumentationBlocks
     * 
     * @param root
     * @param source
     */
    private void attachPostDocumentationBlocks(JSParseRootNode root, String source)
    {
        // process each post-documentation block
        for (Symbol block : this.fScanner.getVSDocComments())
        {
            int index = block.getStart() - 1;

            while (index >= 0 && Character.isWhitespace(source.charAt(index)))
            {
                index--;
            }

            IParseNode node = root.getNodeAtOffset(index);

            if (node instanceof JSNode)
            {
                switch (node.getNodeType())
                {
                    case IJSNodeTypes.STATEMENTS:
                        IParseNode parent = node.getParent();

                        if (parent.getNodeType() == IJSNodeTypes.FUNCTION)
                        {
                            ((JSNode) parent).setPostDocumentation(block);
                        }
                        break;

                    default:
                        ((JSNode) node).setPostDocumentation(block);
                        break;
                }
            }
        }
    }

    /**
     * attachPreDocumentationBlocks
     * 
     * @param root
     * @param source
     */
    private void attachPreDocumentationBlocks(JSParseRootNode root, String source)
    {
        // process each pre-documentation block
        List<Symbol> sDocComments = fScanner.getSDocComments();
        for (Symbol comment : sDocComments)
        {
            int index = comment.getEnd() + 1;

            while (index < source.length() && Character.isWhitespace(source.charAt(index)))
            {
                index++;
            }

            IParseNode node = root.getNodeAtOffset(index);

            if (node instanceof JSNode)
            {
                if (node instanceof JSGroupNode && node.getFirstChild() instanceof JSFunctionNode)
                {
                    ((JSNode) node.getFirstChild()).setPreDocumentation(comment);
                }
                else if (node instanceof JSIdentifierNode && node.getParent() instanceof JSNameValuePairNode)
                {
                    // associate documentation with property's value
                    JSNameValuePairNode entry = (JSNameValuePairNode) node.getParent();
                    ((JSNode) entry.getValue()).setPreDocumentation(comment);
                }
                else
                {
                    IParseNode statement = ((JSNode) node).getContainingStatementNode();

                    if (statement instanceof JSAssignmentNode)
                    {
                        ((JSNode) statement.getLastChild()).setPreDocumentation(comment);
                    }
                    else
                    {
                        switch (node.getNodeType())
                        {
                            case IJSNodeTypes.VAR:
                                // associate documentation with first declared variable's value
                                JSVarNode varNode = (JSVarNode) node;
                                ((JSNode) varNode.getFirstChild().getLastChild()).setPreDocumentation(comment);
                                break;

                            default:
                                ((JSNode) node).setPreDocumentation(comment);
                                break;
                        }
                    }
                }
            }
        }
    }

	/**
	 * getNextSymbolIndex
	 * 
	 * @return
	 */
	protected Symbol getLastSymbol()
	{
		Symbol result = null;

		if (0 <= this.top && this.top < this._symbols.length)
		{
			result = this._symbols[this.top];
		}

		return result;
	}

    public synchronized ParseResult parse(IParseState parseState) throws java.lang.Exception
    {
        WorkingParseResult working = new WorkingParseResult();
        parse(parseState, working);
        return working.getImmutableResult();
    }


	/*
	 * (non-Javadoc)
	 * @see com.aptana.parsing.IParser#parse(com.aptana.parsing.IParseState)
	 */
	protected synchronized void parse(IParseState parseState, WorkingParseResult working) throws java.lang.Exception
	{
		fWorking = working;
		String severity = Platform.getPreferencesService().getString(JSCorePlugin.PLUGIN_ID, IPreferenceConstants.PREF_MISSING_SEMICOLON_SEVERITY, null, null);
		fSemicolonSeverity = IProblem.Severity.create(severity);

		// make sure we have some source
		String source = parseState.getSource();

		// create scanner and send source to it
		fScanner = new JSFlexScanner();
		fScanner.setSource(source);

		// determine if we need to collect and/or attach comments
		boolean attachComments = true;
		boolean collectComments = true;

		if (parseState instanceof JSParseState)
		{
			JSParseState jsParseState = (JSParseState) parseState;

			// NOTE: In order to attach comments, we have to collect them, hence the OR in collectComments
			attachComments = jsParseState.attachComments();
			collectComments = jsParseState.attachComments() || jsParseState.collectComments();
		}

		fScanner.setCollectComments(collectComments);

		try
		{
			JSParseRootNode result;
			try
			{
				// parse
				result = (JSParseRootNode) parse(fScanner);

				if (attachComments)
				{
					attachComments(source, result);
				}

				if (collectComments)
				{
					collectComments(result);
				}
			}
			finally
			{
				// clear scanner for garbage collection
				if (fScanner != null)
				{
					fScanner.yyclose();
					fScanner = null;
				}
			}

			// update node offsets
			int start = parseState.getStartingOffset();
			int length = source.length();

			// align root with zero-based offset
			result.setLocation(0, length - 1);

			if (start != 0)
			{
				// shift all offsets to the correct position
				ParseUtil.addOffset(result, start);
			}

			// store results in the parse state
			fWorking.setParseResult(result);
		}
		finally
		{
			fWorking = null;
		}
	}

	
    private void attachComments(String source, JSParseRootNode result)
    {
        // attach documentation
        attachPreDocumentationBlocks(result, source);
        attachPostDocumentationBlocks(result, source);
    }

    private void collectComments(JSParseRootNode result)
    {
        // create a list of all comments and attach to root node

        List<Symbol> sDocComments = fScanner.getSDocComments();
        List<Symbol> vsDocComments = fScanner.getVSDocComments();
        List<Symbol> singleLineComments = fScanner.getSingleLineComments();
        List<Symbol> multiLineComments = fScanner.getMultiLineComments();

        List<JSCommentNode> comments = new ArrayList<JSCommentNode>(sDocComments.size() + vsDocComments.size()
                + singleLineComments.size() + multiLineComments.size());

        for (Symbol symbol : sDocComments)
        {
            comments.add(new JSCommentNode(IJSNodeTypes.SDOC_COMMENT, symbol.getStart(), symbol.getEnd()));
        }

        for (Symbol symbol : vsDocComments)
        {
            comments.add(new JSCommentNode(IJSNodeTypes.VSDOC_COMMENT, symbol.getStart(), symbol.getEnd()));
        }

        for (Symbol symbol : singleLineComments)
        {
            comments.add(new JSCommentNode(IJSNodeTypes.SINGLE_LINE_COMMENT, symbol.getStart(), symbol.getEnd()));
        }

        for (Symbol symbol : multiLineComments)
        {
            comments.add(new JSCommentNode(IJSNodeTypes.MULTI_LINE_COMMENT, symbol.getStart(), symbol.getEnd()));
        }

        result.setCommentNodes(comments.toArray(new IParseNode[comments.size()]));
    }

	/*
	 * (non-Javadoc)
	 * @see beaver.Parser#recoverFromError(beaver.Symbol, beaver.Parser.TokenStream)
	 */
	@Override
	protected void recoverFromError(Symbol token, TokenStream in) throws IOException, Parser.Exception
	{
		boolean success = false;

		if (this.recoveryStrategies != null)
		{
			// NOTE: Consider building a Map<Object,List<IRecoveryStrategy>> which
			// would allow us to reduce the number of recovery strategies that will
			// be attempted based on the last symbol on the stack. We may need
			// catch-all cases: 1) try these before the mapped strategies, 2)
			// try the strategies, 3) try these after the mapped strategies
			for (IRecoveryStrategy strategy : this.recoveryStrategies)
			{
				if (strategy.recover(this, getLastSymbol(), token, in, report))
				{
					success = true;
					break;
				}
			}
		}

		if (success == false)
		{
			super.recoverFromError(token, in);
		}
	}
:};

%init {:
		report = new JSEvents();

		// @formatter:off
		recoveryStrategies = new ArrayList<IRecoveryStrategy>(10);

		recoveryStrategies.add(new JSInsertionRecoveryStrategy(JSTokenType.SEMICOLON, ";")
		{
			public boolean recover(IParser parser, Symbol lastToken, Symbol currentToken, TokenStream in, Events report)
					throws IOException
			{
				boolean recovered = super.recover(parser, lastToken, currentToken, in, report);
				if (recovered && fSemicolonSeverity != IProblem.Severity.IGNORE)
				{
					fWorking.addError(new ParseError(IJSConstants.CONTENT_TYPE_JS, lastToken, Messages.JSParser_MissingSemicolonMsg, fSemicolonSeverity));
				}
				return recovered;
			}
		});
		recoveryStrategies.add(new JSInsertionRecoveryStrategy(JSTokenType.RPAREN, ")", JSTokenType.SEMICOLON, ";"));
		recoveryStrategies.add(new JSInsertionRecoveryStrategy(JSTokenType.IDENTIFIER, "", JSTokenType.SEMICOLON, ";", JSTokenType.DOT, JSTokenType.NEW, JSTokenType.EQUAL));
		recoveryStrategies.add(new JSInsertionRecoveryStrategy(JSTokenType.IDENTIFIER, "", JSTokenType.DOT, JSTokenType.NEW, JSTokenType.EQUAL));
		recoveryStrategies.add(new JSInsertionRecoveryStrategy(JSTokenType.IDENTIFIER, "", JSTokenType.LPAREN));
		recoveryStrategies.add(new JSInsertionRecoveryStrategy(JSTokenType.IDENTIFIER, "", JSTokenType.COLON, ":", JSTokenType.DOT));
		recoveryStrategies.add(new JSInsertionRecoveryStrategy(JSTokenType.LCURLY, "{", JSTokenType.RCURLY, "}", JSTokenType.RPAREN));
		recoveryStrategies.add(new IRecoveryStrategy()
		{
			public boolean recover(IParser parser, Symbol lastToken, Symbol currentToken, TokenStream in, Parser.Events report) throws IOException
			{
				boolean result = false;

				if (top >= 2)
				{
					Symbol symbol1 = _symbols[top - 2];
					Symbol symbol2 = _symbols[top - 1];

					if (lastToken.getId() == JSTokenType.COMMA.getIndex() && symbol2.value instanceof List<?> && symbol1.getId() == JSTokenType.LPAREN.getIndex())
					{
						Symbol term = new Symbol(JSTokenType.IDENTIFIER.getIndex(), currentToken.getStart(), currentToken.getStart() - 1, "");
						Simulator sim = new Simulator();

						in.alloc(2);
						in.insert(term, currentToken);
						in.rewind();

						if (sim.parse(in))
						{
							result = true;

							in.rewind();

							report.missingTokenInserted(term);
						}
					}
				}

				return result;
			}
		});

		JSInsertionRecoveryStrategy completeProperty = new JSInsertionRecoveryStrategy(JSTokenType.IDENTIFIER, "");
		completeProperty.addCurrentTokenTypes(JSTokenType.RCURLY);
		recoveryStrategies.add(completeProperty);

		JSInsertionRecoveryStrategy completeProperty2 = new JSInsertionRecoveryStrategy(JSTokenType.COLON, ":", JSTokenType.IDENTIFIER, "");
		completeProperty2.addCurrentTokenTypes(JSTokenType.RCURLY);
		recoveryStrategies.add(completeProperty2);
		// @formatter:on
:};

%terminals FUNCTION, IDENTIFIER, STRING, NUMBER, NULL, TRUE, FALSE, REGEX, GET, SET, AS, FROM, DOT_DOT_DOT, ARROW, TARGET, OF;
%terminals LCURLY, RCURLY, LPAREN, RPAREN, LBRACKET, RBRACKET, COMMA, COLON, SEMICOLON, EQUAL, DOT, QUESTION;
%terminals IF, ELSE, DO, WHILE, FOR, IN, CONTINUE, BREAK, RETURN, WITH, SWITCH, CASE, DEFAULT, THROW, TRY, CATCH, FINALLY;
%terminals LET, CONST, VAR, THIS, NEW, DELETE, PLUS_PLUS, MINUS_MINUS, PLUS, MINUS, EXCLAMATION, TILDE, TYPEOF, VOID, AMPERSAND, CARET, PIPE, AMPERSAND_AMPERSAND, PIPE_PIPE;
%terminals STAR, FORWARD_SLASH, PERCENT, LESS_LESS, GREATER_GREATER, GREATER_GREATER_GREATER;
%terminals LESS, GREATER, LESS_EQUAL, GREATER_EQUAL, INSTANCEOF, IN, EQUAL_EQUAL, EXCLAMATION_EQUAL, EQUAL_EQUAL_EQUAL, EXCLAMATION_EQUAL_EQUAL;
%terminals EQUAL, STAR_EQUAL, FORWARD_SLASH_EQUAL, PERCENT_EQUAL, PLUS_EQUAL, MINUS_EQUAL, LESS_LESS_EQUAL, GREATER_GREATER_EQUAL, GREATER_GREATER_GREATER_EQUAL, AMPERSAND_EQUAL, CARET_EQUAL, PIPE_EQUAL;
%terminals AWAIT, DEBUGGER, CLASS, ENUM, EXPORT, EXTENDS, IMPORT, SUPER, IMPLEMENTS, INTERFACE, PACKAGE, PRIVATE, PROTECTED, PUBLIC, STATIC, YIELD;
%terminals NO_SUB_TEMPLATE, TEMPLATE_HEAD, TEMPLATE_MIDDLE, TEMPLATE_TAIL;

%typeof ArrayLiteral = "JSArrayNode";
%typeof ObjectLiteral = "JSObjectNode";
%typeof ObjectBindingPattern = "JSObjectNode";
%typeof ArrayBindingPattern = "JSArrayNode";
%typeof WithStatement, WithStatement_NoIf = "JSWithNode";
%typeof CaseClause = "JSCaseNode";
%typeof DefaultClause = "JSDefaultNode";
%typeof LabelledStatement, LabelledStatement_NoIf = "JSLabelledNode";
%typeof TryStatement = "JSTryNode";
%typeof Catch = "JSCatchNode";
%typeof Finally = "JSFinallyNode";
%typeof NullLiteral = "JSNullNode";
%typeof BooleanLiteral = "JSPrimitiveNode";
%typeof NumericLiteral = "JSNumberNode";
%typeof StringLiteral = "JSStringNode";
%typeof RegularExpressionLiteral = "JSRegexNode";
%typeof Elision = "JSElisionNode";
%typeof StatementListItem, Statement, Statement_NoIf, Declaration, VariableDeclaration, BindingProperty, SingleExpression, ModuleItem, PropertyDefinition, ArgumentListItem = "JSNode";
%typeof BindingElisionElement, LexicalBinding, ForBinding, ForDeclaration, LabelledItem, LabelledItem_NoIf, CatchParameter, FormalParameter, PropertyName = "JSNode";
%typeof LexicalDeclaration, VariableStatement = "JSVarNode";
%typeof Expression = "JSNode";
%typeof ElementList = "JSElementsNode";
%typeof Arguments = "JSArgumentsNode";
%typeof Initializer = "JSInitializerNode";
%typeof CoverInitializedName = "JSDeclarationNode";
%typeof SingleNameBinding= "JSNode";
%typeof CaseBlock, FormalParameterList = "ArrayList";
%typeof Block, FunctionStatementList, FunctionBody = "JSStatementsNode";
%typeof FormalParameters = "JSParametersNode";
%typeof BindingPattern, BindingElement = "JSNode";
%typeof IfStatement, IfStatement_NoIf = "JSIfNode";

%left LPAREN, RPAREN, LBRACKET, RBRACKET, DOT;
%right PLUS_PLUS, MINUS_MINUS, EXCLAMATION, TILDE, DELETE, NEW, TYPEOF, VOID;
%left FORWARD_SLASH, STAR, PERCENT;
%left PLUS, MINUS;
%left GREATER_GREATER, LESS_LESS, GREATER, GREATER_EQUAL, LESS, LESS_EQUAL;
%left EQUAL_EQUAL, EXCLAMATION_EQUAL, EQUAL_EQUAL_EQUAL, EXCLAMATION_EQUAL_EQUAL;
%left AMPERSAND;
%left CARET;
%left PIPE;
%left AMPERSAND_AMPERSAND;
%left PIPE_PIPE;
%left QUESTION, COLON;
%right EQUAL;
%right STAR_EQUAL, FORWARD_SLASH_EQUAL, PERCENT_EQUAL, PLUS_EQUAL, MINUS_EQUAL, LESS_LESS_EQUAL, GREATER_GREATER_EQUAL, GREATER_GREATER_GREATER_EQUAL, AMPERSAND_EQUAL, CARET_EQUAL, PIPE_EQUAL;
%left COMMA;



%goal Module;
%goal Script;

////////////////////////////////////
// A.2 Expressions
////////////////////////////////////

// IdentifierName minus ReservedWords
Identifier
	=	IDENTIFIER
	|	GET
	|	IMPLEMENTS
	|	INTERFACE
//	|	LET
	|	OF
	|	PACKAGE
	|	PRIVATE
	|	PROTECTED
	|	PUBLIC
	|	SET
	|	STATIC
	|	TARGET
	;

IdentifierName
	=	Identifier
	|	AWAIT
	|	BREAK
	|	CASE
	|	CATCH
	|	CLASS
	|	CONST
	|	CONTINUE
	|	DEBUGGER
	|	DEFAULT
	|	DELETE
	|	DO
	|	ELSE
	|	ENUM
	|	EXPORT
	|	EXTENDS
	|	FINALLY
	|	FOR
	|	FUNCTION
	|	IF
	|	IMPORT
	|	INSTANCEOF
	|	IN
	|	NEW
	|	RETURN
	|	SUPER
	|	SWITCH
	|	THIS
	|	THROW
	|	TRY
	|	TYPEOF
	|	VAR
	|	VOID
	|	WHILE
	|	WITH
	|	BooleanLiteral
	|	NullLiteral
	;

CoverParenthesizedExpressionAndArrowParameterList
	=	LPAREN.l Expression.e RPAREN.r
		{:
			return new JSGroupNode(l, e, r);
		:}
	|	LPAREN RPAREN
	|	LPAREN DOT_DOT_DOT Identifier RPAREN
	|	LPAREN Expression COMMA DOT_DOT_DOT Identifier RPAREN
	;

Literal
	=	NullLiteral
	|	BooleanLiteral
	|	NumericLiteral
	|	StringLiteral
	;

NullLiteral
	=	NULL.n
		{:
			return new JSNullNode(n);
		:}
	;

BooleanLiteral
	=	TRUE.t
		{:
			return new JSTrueNode(t);
		:}
	|	FALSE.f
		{:
			return new JSFalseNode(f);
		:}
	;

NumericLiteral
	=	NUMBER.n
		{:
			return new JSNumberNode(n);
		:}
	;

StringLiteral
	=	STRING.s
		{:
			return new JSStringNode(s);
		:}
	;
	
RegularExpressionLiteral
	=	REGEX.r
		{:
			return new JSRegexNode(r);
		:}
	;

ArrayLiteral
	=	LBRACKET.l Elision.e? RBRACKET.r
		{:
			if (e == null) {
				return new JSArrayNode(l, r);
			}
			e.addChild(new JSNullNode());
			return new JSArrayNode(l, r, e);
		:}
	|	LBRACKET.l ElementList.e RBRACKET.r
		{:
			return new JSArrayNode(l, r, e);
		:}
	|	LBRACKET.l ElementList.e COMMA Elision.n? RBRACKET.r
		{:
			if (n == null) {
				return new JSArrayNode(l, r, e, new JSNullNode());
			}
			n.addChild(new JSNullNode());
			return new JSArrayNode(l, r, e, n);
		:}
	;

// TODO: handle SpreadElement cases!
ElementList
	=	Elision.n? SingleExpression.e
		{:
			if (n == null) {
				return new JSElementsNode(e);
			}
			return new JSElementsNode(n, e);
		:}
	|	Elision.n? SpreadElement.e
	|	ElementList.l COMMA Elision.n? SingleExpression.e
		{:
			if (n != null) {
				l.addChild(n);
			}
			l.addChild(e);

			return l;
		:}
	|	ElementList.l COMMA Elision.n? SpreadElement.e
	;

Elision
	=	Elision.e COMMA
		{:
			e.addChild(new JSNullNode());

			return e;
		:}
	|	COMMA
		{:
			return new JSElisionNode(new JSNullNode());
		:}
	;

SpreadElement
	=	DOT_DOT_DOT SingleExpression
	;


ObjectLiteral
	=	LCURLY.l RCURLY.r
		{:
			return new JSObjectNode(l, r);
		:}
	|	LCURLY.l PropertyDefinitionList.p COMMA? RCURLY.r
		{:
			return new JSObjectNode(l, r, p);
		:}
	;

PropertyDefinitionList
	=	PropertyDefinition
// FIXME This plus PropertyDefinition = Identifier cause a conflict!
	|	PropertyDefinitionList COMMA PropertyDefinition
	;

PropertyDefinition
// FIXME This Identifier rule plus PropertyDefinitionList = PropertyDefinitionList COMMA PropertyDefinition cause a conflict around trailing COMMA
//	=	Identifier
	=	CoverInitializedName
	|	PropertyName.n COLON.c SingleExpression.v
		{:
			return new JSNameValuePairNode(n, c, v);
		:}
	|	MethodDefinition
	;

PropertyName
	=	LiteralPropertyName
	|	ComputedPropertyName
	;

LiteralPropertyName
	=	IdentifierName.i
		{:
			return new JSIdentifierNode(i);
		:}
	|	StringLiteral
	|	NumericLiteral
	;

ComputedPropertyName
	=	LBRACKET SingleExpression RBRACKET
	;

CoverInitializedName
	=	Identifier.i Initializer.z
		{:
			return new JSDeclarationNode(new JSIdentifierNode(i), z.getEquals(), z.getExpression());
		:}
	;

Initializer
	=	EQUAL.e SingleExpression.expr
		{:
			return new JSInitializerNode(e, expr);
		:}
	;

TemplateLiteral
	=	NoSubstitutionTemplate
	|	TemplateHead Expression TemplateSpans
	;

TemplateSpans
	=	TemplateTail
	|	TemplateMiddleList TemplateTail
	;

TemplateMiddleList
	=	TemplateMiddle Expression
	|	TemplateMiddleList TemplateMiddle Expression
	;

Arguments
	=	LPAREN RPAREN
		{:
			return new JSArgumentsNode();
		:}
	|	LPAREN ArgumentList.a RPAREN
		{:
			return new JSArgumentsNode(a);
		:}
	;

ArgumentList
	=	ArgumentListItem
	|	ArgumentList COMMA ArgumentListItem
	;
	
ArgumentListItem
	=	SingleExpression
	|	DOT_DOT_DOT SingleExpression
	;

MultiplicativeOperator
	=	STAR
	|	FORWARD_SLASH
	|	PERCENT
	;

AssignmentOperator
	=	STAR_EQUAL
	|	FORWARD_SLASH_EQUAL
	|	PERCENT_EQUAL
	|	PLUS_EQUAL
	|	MINUS_EQUAL
	|	LESS_LESS_EQUAL
	|	GREATER_GREATER_EQUAL
	|	GREATER_GREATER_GREATER_EQUAL
	|	AMPERSAND_EQUAL
	|	CARET_EQUAL
	|	PIPE_EQUAL
	;

// This seems to cause all sorts of issues.
// In ES5.1, this grammar broke it down in a way they could handle: https://github.com/antlr/grammars-v4/blob/master/ecmascript/ECMAScript.g4

Expression
	=	SingleExpression
// FIXME This roll up of single expression conflicts with roll up of PropertyDefinition when base rule is Identifier!
// FIXME We shouldn't use this wrapping JSCommaNode in our AST! Just let it convert into JSNode[] as it does!
	|	Expression.l COMMA SingleExpression.r
		{:
			return new JSCommaNode(l, r);
		:}
	;

// try to generate a huge variant of all the expressions
SingleExpression
	=	FunctionExpression
// FIXME: The grammar is ambiguous here. ClassExpression is CLASS BindingIdentifier? ClassTail, while ClassDeclaration is effectively the same thing
// It's very similar to FunctionExpression/FunctionDeclaration (identifier is optional for expression)
// AND GeneratorExpression/GeneratorDeclaration (identifier is optional for expression)
//	|	ClassDeclaration			// ClassExpression is equivalent
	|	GeneratorExpression
	|	RegularExpressionLiteral
	|	TemplateLiteral
	|	CoverParenthesizedExpressionAndArrowParameterList
	|	SingleExpression.l LBRACKET.lb Expression.r RBRACKET.rb
		{:
			return new JSGetElementNode(l, lb, r, rb);
		:}
	|	SingleExpression.l TemplateLiteral
	|	SUPER LBRACKET Expression RBRACKET
	|	SUPER DOT IdentifierName
	|	NEW DOT TARGET
	|	NEW SingleExpression.e
		{:
			// FIXME The second argument should be the Arguments node here
			return new JSConstructNode(e, new JSEmptyNode(e));
		:}
// FIXME This conflicts with MethodDeclaration = PropertyName LPAREN StrictFormalParameters RPAREN LCURLY FunctionBody RCURLY
// Where PropertyName is a NumericLiteral, StringLiteral or Identifier...
	|	SingleExpression.l Arguments.r
		{:
			return new JSInvokeNode(l, r);
		:}
	|	SUPER Arguments
	|	SingleExpression.l DOT.o IdentifierName.r
		{:
			return new JSGetPropertyNode(l, o, new JSIdentifierNode(r));
		:}
	|	SingleExpression.e PostUnaryOperator.o
		{:
			return new JSPostUnaryOperatorNode(o, e);
		:}
	|	PreUnaryOperator.o SingleExpression.e
		{:
			return new JSPreUnaryOperatorNode(o, e);
		:}
	|	SingleExpression.l BinaryArithmeticOperator.o SingleExpression.r
		{:
			return new JSBinaryArithmeticOperatorNode(l, o, r);
		:}
	|	SingleExpression.l BinaryBooleanOperator.o SingleExpression.r
		{:
			return new JSBinaryBooleanOperatorNode(l, o, r);
		:}
	|	SingleExpression.l QUESTION.q SingleExpression.t COLON.c SingleExpression.f
		{:
			return new JSConditionalNode(l, q, t, c, f);
		:}
	|	YieldExpression
	|	ArrowFunction
	|	SingleExpression.l EQUAL.o SingleExpression.r
		{:
			return new JSAssignmentNode(l, o, r);
		:}
	|	SingleExpression.l AssignmentOperator.o SingleExpression.r
		{:
			return new JSAssignmentNode(l, o, r);
		:}
	|	THIS.t
		{:
			return new JSThisNode(t);
		:}
	|	Identifier.i
		{:
			return new JSIdentifierNode(i);
		:}
	|	Literal
	|	ArrayLiteral
	|	ObjectLiteral
	;

PostUnaryOperator
	=	PLUS_PLUS
	|	MINUS_MINUS
	;

PreUnaryOperator
	=	PostUnaryOperator
	|	DELETE
	|	VOID
	|	TYPEOF
	|	PLUS
	|	MINUS
	|	TILDE
	|	EXCLAMATION
	;

BinaryArithmeticOperator
	=	MultiplicativeOperator
	|	PIPE
	|	CARET
	|	AMPERSAND
	|	PLUS
	|	MINUS
	|	LESS_LESS
	|	GREATER_GREATER
	|	GREATER_GREATER_GREATER
	;

BinaryBooleanOperator
	=	PIPE_PIPE
	|	AMPERSAND_AMPERSAND
	|	EXCLAMATION_EQUAL_EQUAL
	|	EQUAL_EQUAL_EQUAL
	|	EXCLAMATION_EQUAL
	|	EQUAL_EQUAL
	|	IN
	|	INSTANCEOF
	|	LESS
	|	GREATER
	|	LESS_EQUAL
	|	GREATER_EQUAL
	;
////////////////////////////////////
// A.3 Statements
////////////////////////////////////
Statement
	=	BlockStatement
	|	VariableStatement
	|	EmptyStatement
	|	ExpressionStatement
	|	IfStatement
	|	BreakableStatement
	|	ContinueStatement
	|	BreakStatement
	|	ReturnStatement
	|	WithStatement
	|	LabelledStatement
	|	ThrowStatement
	|	TryStatement
	|	DebuggerStatement
	|	error
		{:
			return new JSErrorNode();
		:}
	;
	
Statement_NoIf
	=	BlockStatement
	|	VariableStatement
	|	EmptyStatement
	|	ExpressionStatement
	|	IfStatement_NoIf
	|	BreakableStatement_NoIf
	|	ContinueStatement
	|	BreakStatement
	|	ReturnStatement
	|	WithStatement_NoIf
	|	LabelledStatement_NoIf
	|	ThrowStatement
	|	TryStatement
	|	DebuggerStatement
	|	error
		{:
			return new JSErrorNode();
		:}
	;

EmptyStatement
	=	SEMICOLON.s
		{:
			JSNode node = new JSEmptyNode(s);
			node.setSemicolonIncluded(true);
			return node;
		:}
	;

Declaration
	=	HoistableDeclaration
	|	ClassDeclaration
	|	LexicalDeclaration
	;

HoistableDeclaration
	=	FunctionDeclaration
	|	GeneratorDeclaration
	;

BreakableStatement
	=	IterationStatement
	|	SwitchStatement
	;
	
BreakableStatement_NoIf
	=	IterationStatement_NoIf
	|	SwitchStatement
	;

BlockStatement
	=	Block
	;

Block
	=	LCURLY StatementList.a? RCURLY
		{:
			if (a == null) {
				return new JSStatementsNode();
			}
			return new JSStatementsNode(a);
		:}
	;

// Roughly equivalent to old SourceElements non-terminal
StatementList
	=	StatementList StatementListItem
	|	StatementListItem
	;

// Roughly equivalent to old SourceElement non-terminal
StatementListItem
	=	Statement
	|	Declaration
	;

LexicalDeclaration
	=	LetOrConst.v BindingList.l SEMICOLON
		{:
			JSNode node = new JSVarNode(v, l);
			node.setSemicolonIncluded(true);
			return node;
		:}
	;

LetOrConst
	=	LET
	|	CONST
	;

BindingList
	=	BindingList COMMA LexicalBinding
	|	LexicalBinding
	;

LexicalBinding
	=	Identifier.i Initializer.z?
		{:
			if (z == null) {
				return new JSDeclarationNode(new JSIdentifierNode(i), null, new JSEmptyNode(i));
			} else {
				return new JSDeclarationNode(new JSIdentifierNode(i), z.getEquals(), z.getExpression());
			}
		:}
	|	BindingPattern Initializer
	;

VariableStatement
	=	VAR.v VariableDeclarationList.l SEMICOLON
		{:
			JSNode node = new JSVarNode(v, l);
			node.setSemicolonIncluded(true);
			return node;
		:}
	;

VariableDeclarationList
	=	VariableDeclarationList COMMA VariableDeclaration
	|	VariableDeclaration
	;

// TODO Combine LexicalBinding and VariableDeclaration!
// TODO Refactor with CoverInitializedName and SingleNameBinding
VariableDeclaration
	=	Identifier.i Initializer.z?
		{:
			if (z == null) {
				return new JSDeclarationNode(new JSIdentifierNode(i), null, new JSEmptyNode(i));
			} else {
				return new JSDeclarationNode(new JSIdentifierNode(i), z.getEquals(), z.getExpression());
			}
		:}
	|	BindingPattern Initializer
	;

BindingPattern
	=	ObjectBindingPattern
	|	ArrayBindingPattern
	;

ObjectBindingPattern
	=	LCURLY.l RCURLY.r
		{:
			return new JSObjectNode(l, r);
		:}
	|	LCURLY.l BindingPropertyList.p RCURLY.r
		{:
			return new JSObjectNode(l, r, p);
		:}
	|	LCURLY.l BindingPropertyList.p COMMA RCURLY.r
		{:
			return new JSObjectNode(l, r, p);
		:}
	;

ArrayBindingPattern
	=	LBRACKET.l Elision.e? BindingRestElement.n? RBRACKET.r
		{:
			// FIXME Handle elision, rest element
			return new JSArrayNode(l, r, e);
		:}
	|	LBRACKET.l BindingElementList.n RBRACKET.r
		{:
			return new JSArrayNode(l, r, n);
		:}
	|	LBRACKET.l BindingElementList.n COMMA Elision.e? BindingRestElement.z? RBRACKET.r
		{:
			// FIXME Handle elision, rest element
			return new JSArrayNode(l, r, n);
		:}
	;

BindingPropertyList
	=	BindingPropertyList COMMA BindingProperty
	|	BindingProperty
	;

BindingElementList
	=	BindingElementList COMMA BindingElisionElement
	|	BindingElisionElement
	;

BindingElisionElement
	=	Elision? BindingElement
	;

BindingProperty
	=	SingleNameBinding
	|	PropertyName.n COLON.c BindingElement.e
		{:
			return new JSNameValuePairNode(n, c, e);
		:}
	;

BindingElement
	=	SingleNameBinding
	|	BindingPattern Initializer?
	;

SingleNameBinding
	=	Identifier.i Initializer.z?
		{:
			if (z == null) {
				return new JSIdentifierNode(i);
			}
			return new JSDeclarationNode(new JSIdentifierNode(i), z.getEquals(), z.getExpression());
		:}
	;

BindingRestElement
	=	DOT_DOT_DOT Identifier
	;

ExpressionStatement
	=	Expression.e SEMICOLON
		{:
			e.setSemicolonIncluded(true);
			return e;
		:}
	;

IfStatement
	=	IF LPAREN.l Expression.e RPAREN.r Statement_NoIf.sn ELSE Statement.s
		{:
			return new JSIfNode(l, e, r, sn, s);
		:}
	|	IF LPAREN.l Expression.e RPAREN.r Statement.s
		{:
			return new JSIfNode(l, e, r, s, new JSEmptyNode(s));
		:}
	;

IfStatement_NoIf
	=	IF LPAREN.l Expression.e RPAREN.r Statement_NoIf.sn ELSE Statement_NoIf.s
		{:
			return new JSIfNode(l, e, r, sn, s);
		:}
	;

IterationStatement
	=	DO Statement.s WHILE LPAREN.l Expression.e RPAREN.r SEMICOLON.s1
		{:
 			JSNode node = new JSDoNode(s, l, e, r);
 			node.setSemicolonIncluded(true);
 			return node;
 		:}
	|	WHILE LPAREN.l Expression.e RPAREN.r Statement.s
		{:
 			return new JSWhileNode(l, e, r, s);
 		:}
// FIXME [lookahead not in {let [}]
	|	FOR LPAREN.l Expression.e1? SEMICOLON.s1 Expression.e2? SEMICOLON.s2 Expression.e3? RPAREN.r Statement.s
		{:
			JSNode expr1 = e1;
			if (expr1 == null) {
				expr1 = new JSEmptyNode(l);
			}
			JSNode expr2 = e2;
			if (expr2 == null) {
				expr2 = new JSEmptyNode(s1);
			}
			JSNode expr3 = e3;
			if (expr3 == null) {
				expr3 = new JSEmptyNode(s2);
			}
 			return new JSForNode(l, expr1, s1, expr2, s2, expr3, r, s);
 		:}
	|	FOR LPAREN.l VAR.v VariableDeclarationList.i SEMICOLON.s1 Expression.e1? SEMICOLON.s2 Expression.e2? RPAREN.r Statement.s
		{:
			JSNode expr1 = e1;
			if (expr1 == null) {
				expr1 = new JSEmptyNode(s1);
			}
			JSNode expr2 = e2;
			if (expr2 == null) {
				expr2 = new JSEmptyNode(s2);
			}
 			return new JSForNode(l, new JSVarNode(v, i), s1, expr1, s2, expr2, r, s);
 		:}
	|	FOR LPAREN.l LexicalDeclaration.decl Expression.e1? SEMICOLON.s1 Expression.e2? RPAREN.r Statement.s
		{:
			JSNode expr1 = e1;
			if (expr1 == null) {
				expr1 = new JSEmptyNode(l);
			}
			JSNode expr2 = e2;
			if (expr2 == null) {
				expr2 = new JSEmptyNode(s1);
			}
			// FIXME Grab semicolon from decl to inject here?
 			return new JSForNode(l, decl, null, expr1, s1, expr2, r, s);
 		:}
// FIXME [lookahead not in {let [}]
	|	FOR LPAREN.l SingleExpression.i IN.in Expression.o RPAREN.r Statement.s
		{:
 			return new JSForInNode(l, i, in, o, r, s);
 		:}
	|	FOR LPAREN.l VAR.v ForBinding.i IN.in Expression.o RPAREN.r Statement.s
		{:
 			return new JSForInNode(l, new JSVarNode(v, i), in, o, r, s);
 		:}
	|	FOR LPAREN.l ForDeclaration.decl IN.in Expression.o RPAREN.r Statement.s
		{:
 			return new JSForInNode(l, decl, in, o, r, s);
 		:}
// FIXME [lookahead not in {let [}]
	|	FOR LPAREN.l SingleExpression.i OF.of SingleExpression.o RPAREN.r Statement.s
		{:
 			return new JSForOfNode(l, i, of, o, r, s);
 		:}
	|	FOR LPAREN.l VAR.v ForBinding.i OF.of SingleExpression.o RPAREN.r Statement.s
		{:
 			return new JSForOfNode(l, new JSVarNode(v, i), of, o, r, s);
 		:}
	|	FOR LPAREN.l ForDeclaration.decl OF.of SingleExpression.o RPAREN.r Statement.s
		{:
 			return new JSForOfNode(l, decl, of, o, r, s);
 		:}
	;
	
IterationStatement_NoIf
	=	DO Statement.s WHILE LPAREN.l Expression.e RPAREN.r SEMICOLON.s1
		{:
 			JSNode node = new JSDoNode(s, l, e, r);
 			node.setSemicolonIncluded(true);
 			return node;
 		:}
	|	WHILE LPAREN.l Expression.e RPAREN.r Statement_NoIf.s
		{:
 			return new JSWhileNode(l, e, r, s);
 		:}
// FIXME [lookahead not in {let [}]
	|	FOR LPAREN.l Expression.e1? SEMICOLON.s1 Expression.e2? SEMICOLON.s2 Expression.e3? RPAREN.r Statement_NoIf.s
		{:
			JSNode expr1 = e1;
			if (expr1 == null) {
				expr1 = new JSEmptyNode(l);
			}
			JSNode expr2 = e2;
			if (expr2 == null) {
				expr2 = new JSEmptyNode(s1);
			}
			JSNode expr3 = e3;
			if (expr3 == null) {
				expr3 = new JSEmptyNode(s2);
			}
 			return new JSForNode(l, expr1, s1, expr2, s2, expr3, r, s);
 		:}
	|	FOR LPAREN.l VAR.v VariableDeclarationList.i SEMICOLON.s1 Expression.e1? SEMICOLON.s2 Expression.e2? RPAREN.r Statement_NoIf.s
		{:
			JSNode expr1 = e1;
			if (expr1 == null) {
				expr1 = new JSEmptyNode(s1);
			}
			JSNode expr2 = e2;
			if (expr2 == null) {
				expr2 = new JSEmptyNode(s2);
			}
 			return new JSForNode(l, new JSVarNode(v, i), s1, expr1, s2, expr2, r, s);
 		:}
	|	FOR LPAREN.l LexicalDeclaration.decl Expression.e1? SEMICOLON.s1 Expression.e2? RPAREN.r Statement_NoIf.s
		{:
			JSNode expr1 = e1;
			if (expr1 == null) {
				expr1 = new JSEmptyNode(l);
			}
			JSNode expr2 = e2;
			if (expr2 == null) {
				expr2 = new JSEmptyNode(s1);
			}
			// FIXME Grab semicolon from decl to inject here?
 			return new JSForNode(l, decl, null, expr1, s1, expr2, r, s);
 		:}
// FIXME [lookahead not in {let [}]
	|	FOR LPAREN.l SingleExpression.i IN.in Expression.o RPAREN.r Statement_NoIf.s
		{:
 			return new JSForInNode(l, i, in, o, r, s);
 		:}
	|	FOR LPAREN.l VAR.v ForBinding.i IN.in Expression.o RPAREN.r Statement_NoIf.s
		{:
 			return new JSForInNode(l, new JSVarNode(v, i), in, o, r, s);
 		:}
	|	FOR LPAREN.l ForDeclaration.decl IN.in Expression.o RPAREN.r Statement_NoIf.s
		{:
 			return new JSForInNode(l, decl, in, o, r, s);
 		:}
// FIXME [lookahead not in {let [}]
	|	FOR LPAREN.l SingleExpression.i OF.of SingleExpression.o RPAREN.r Statement_NoIf.s
		{:
 			return new JSForOfNode(l, i, of, o, r, s);
 		:}
	|	FOR LPAREN.l VAR.v ForBinding.i OF.of SingleExpression.o RPAREN.r Statement_NoIf.s
		{:
 			return new JSForOfNode(l, new JSVarNode(v, i), of, o, r, s);
 		:}
	|	FOR LPAREN.l ForDeclaration.decl OF.of SingleExpression.o RPAREN.r Statement_NoIf.s
		{:
 			return new JSForOfNode(l, decl, of, o, r, s);
 		:}
	;

ForDeclaration
	=	LetOrConst ForBinding
	;

ForBinding
	=	Identifier.i
		{:
			return new JSIdentifierNode(i);
		:}
	|	BindingPattern
	;
	
ContinueStatement
	=	CONTINUE SEMICOLON
		{:
			JSNode node = new JSContinueNode();
			node.setSemicolonIncluded(true);
			return node;
		:}
	|	CONTINUE Identifier.i SEMICOLON
		{:
			JSNode node = new JSContinueNode(i);
			node.setSemicolonIncluded(true);
			return node;
		:}
	;

BreakStatement
	=	BREAK SEMICOLON
		{:
			JSNode node = new JSBreakNode();
			node.setSemicolonIncluded(true);
			return node;
		:}
	|	BREAK Identifier.i SEMICOLON
		{:
			JSNode node = new JSBreakNode(i);
			node.setSemicolonIncluded(true);
			return node;
		:}
	;

ReturnStatement
	=	RETURN.r SEMICOLON
		{:
			JSNode node = new JSReturnNode(new JSEmptyNode(r));
			node.setSemicolonIncluded(true);
			return node;
		:}
	|	RETURN Expression.e SEMICOLON
		{:
			JSNode node = new JSReturnNode(e);
			node.setSemicolonIncluded(true);
			return node;
		:}
	;

WithStatement
	=	WITH LPAREN.l Expression.e RPAREN.r Statement.s
		{:
			return new JSWithNode(l, e, r, s);
		:}
	;
	
WithStatement_NoIf
	=	WITH LPAREN.l Expression.e RPAREN.r Statement_NoIf.s
		{:
			return new JSWithNode(l, e, r, s);
		:}
	;

// TODO: Get the curlies out of the block to pass in as args to switch node?
SwitchStatement
	=	SWITCH LPAREN.lp Expression.e RPAREN.rp CaseBlock.children
		{:
			final JSNode[] c1 = children == null ? new JSNode[0] : (JSNode[]) children.toArray(new JSNode[children.size()]);
			return new JSSwitchNode(lp, e, rp, null, null, c1);
		:}
	;

CaseBlock
	=	LCURLY CaseClauses.c? RCURLY
	|	LCURLY CaseClauses.c1? DefaultClause.d CaseClauses.c2? RCURLY
		{:
			List<JSNode> nodes = new ArrayList<JSNode>();
			if (c1 != null) {
				for (JSNode statement : c1)
				{
					nodes.add(statement);
				}
			}
			nodes.add(d);
			if (c2 != null) {
				for (JSNode statement : c2)
				{
					nodes.add(statement);
				}
			}
			return new Symbol(nodes);
		:}
	;

CaseClauses
	=	CaseClause
	|	CaseClauses CaseClause
	;

CaseClause
	=	CASE Expression.e COLON.c StatementList.s?
		{:
			if (s == null) {
				return new JSCaseNode(e, c);
			}
			return new JSCaseNode(e, c, s);
		:}
	;


DefaultClause
	=	DEFAULT COLON.c StatementList.s?
		{:
			if (s == null) {
				return new JSDefaultNode(c);
			}
			return new JSDefaultNode(c, s);
		:}
	;

LabelledStatement
	=	Identifier.i COLON.c LabelledItem.s
		{:
			JSNode id = new JSIdentifierNode(i);
			id.setLocation(i.getStart(), i.getEnd());

			return new JSLabelledNode(id, c, s);
		:}
	;
	
LabelledStatement_NoIf
	=	Identifier.i COLON.c LabelledItem_NoIf.s
		{:
			JSNode id = new JSIdentifierNode(i);
			id.setLocation(i.getStart(), i.getEnd());

			return new JSLabelledNode(id, c, s);
		:}
	;

LabelledItem
	=	Statement
	|	FunctionDeclaration
	;
	
LabelledItem_NoIf
	=	Statement_NoIf
	|	FunctionDeclaration
	;

ThrowStatement
	=	THROW Expression.e SEMICOLON
		{:
			JSNode node = new JSThrowNode(e);
			node.setSemicolonIncluded(true);
			return node;
		:}
	;

TryStatement
	=	TRY Block.b Catch.c
		{:
			return new JSTryNode(b, c, new JSEmptyNode(c));
		:}
	|	TRY Block.b Finally.f
		{:
			return new JSTryNode(b, new JSEmptyNode(b), f);
		:}
	|	TRY Block.b Catch.c Finally.f
		{:
			return new JSTryNode(b, c, f);
		:}
	;

Catch
	=	CATCH LPAREN CatchParameter.p RPAREN Block.b
		{:
			return new JSCatchNode(p, b);
		:}
	;

Finally
	=	FINALLY Block.b
		{:
			return new JSFinallyNode(b);
		:}
	;

CatchParameter
	=	Identifier.i
		{:
			return new JSIdentifierNode(i);
		:}
	|	BindingPattern
	;

DebuggerStatement
	=	DEBUGGER SEMICOLON
	;

////////////////////////////////////
// A.4 Functions and Classes
////////////////////////////////////
FunctionDeclaration
	= 	FUNCTION Identifier.ident LPAREN FormalParameters.params RPAREN LCURLY FunctionBody.body RCURLY
		{:
			return new JSFunctionNode(
				new JSIdentifierNode(ident),
				params,
				body
			);
		:}
	;

FunctionExpression
	=	FUNCTION.f Identifier.ident? LPAREN FormalParameters.params RPAREN LCURLY FunctionBody.body RCURLY
		{:
			if (ident != null) {
				return new JSFunctionNode(
					new JSIdentifierNode(ident),
					params,
					body
				);
			}
			return new JSFunctionNode(
				new JSEmptyNode(f),
				params,
				body
			);
		:}
	;

StrictFormalParameters
	=	FormalParameters
	;

FormalParameters
	=	FormalParameterList.params
		{:
			final JSNode[] p = params == null ? new JSNode[0] : (JSNode[]) params.toArray(new JSNode[params.size()]);
			return new JSParametersNode(p);
		:}
	|
		{:
			return new JSParametersNode();
		:}
	;

FormalParameterList
	=	FunctionRestParameter.p
		{:
			ArrayList lst = new ArrayList();
			lst.add(p);
			return new Symbol(lst);
		:}
	|	FormalsList.l
	|	FormalsList.l COMMA FunctionRestParameter.p
		{:
			_list_l.add(p);
			return _symbol_l;
		:}
	;

FormalsList
	=	FormalsList COMMA FormalParameter
	|	FormalParameter
	;

FunctionRestParameter
	=	BindingRestElement
	;

FormalParameter
	=	BindingElement
	;

FunctionBody
	=	FunctionStatementList
	;

FunctionStatementList
	=	StatementList.s
		{:
			return new JSStatementsNode(s);
		:}
	|
		{:
			return new JSStatementsNode();
		:}
	;

ArrowFunction
	=	ArrowParameters ARROW ConciseBody
	;

ArrowParameters
	=	Identifier
	|	CoverParenthesizedExpressionAndArrowParameterList
	;

ConciseBody
// FIXME Do negative lookahead for '{' in first case
	=	SingleExpression
	|	LCURLY FunctionBody.body RCURLY
	;

// TODO: Handle  propertyName function cases!
// TODO: Handle GeneratorMethod cases!
MethodDefinition
// FIXME: This conflicts with SingleExpression = SingleExpression Arguments
//	=	PropertyName LPAREN StrictFormalParameters RPAREN LCURLY FunctionBody RCURLY
	=	GeneratorMethod
	|	GET PropertyName.n LPAREN RPAREN LCURLY FunctionBody.body RCURLY
		{:
			return new JSNameValuePairNode(n, body);
		:}
	|	SET PropertyName.n LPAREN PropertySetParameterList.p RPAREN LCURLY FunctionBody.body RCURLY
		{:
			JSParametersNode params = new JSParametersNode(p);
			params.setLocation(p.getStartingOffset(), p.getEndingOffset());
			return new JSNameValuePairNode(n, params, body);
		:}
	;

PropertySetParameterList
	=	FormalParameter
	;

GeneratorMethod
	=	STAR PropertyName LPAREN StrictFormalParameters RPAREN LCURLY GeneratorBody RCURLY
	;

GeneratorDeclaration
	=	FUNCTION STAR Identifier LPAREN FormalParameters RPAREN LCURLY GeneratorBody RCURLY
	;

GeneratorExpression
	=	FUNCTION STAR Identifier? LPAREN FormalParameters RPAREN LCURLY GeneratorBody RCURLY
	;

GeneratorBody
	=	FunctionBody
	;
	
YieldExpression
	=	YIELD
	|	YIELD SingleExpression
	|	YIELD STAR SingleExpression
	;

ClassDeclaration
	=	CLASS Identifier ClassTail
	;
	
ClassExpression
	=	CLASS Identifier? ClassTail
	;

ClassTail
	=	ClassHeritage LCURLY ClassBody RCURLY
	|	LCURLY ClassBody RCURLY
	|	ClassHeritage LCURLY RCURLY
	|	LCURLY RCURLY
	;

ClassHeritage
	=	EXTENDS SingleExpression
	;

ClassBody
	=	ClassElementList
	;

ClassElementList
	=	ClassElement
	|	ClassElementList ClassElement
	;

ClassElement
	=	MethodDefinition
	|	STATIC MethodDefinition
	|	SEMICOLON
	;

//FormalParameterList
//	=	FormalParameterList.list COMMA Identifier.ident
//		{:
//			JSNode identifier = new JSIdentifierNode(ident);
//			// add identifier to existing list
//			list.addChild(identifier);
//
//			return list;
//		:}
//	|	Identifier.ident
//		{:
//			JSNode identifier = new JSIdentifierNode(ident);
//
//			return new JSParametersNode(identifier);
//		:}
//	;

//FunctionBody
//	=	LCURLY RCURLY
//		{:
//			return new JSStatementsNode();
//		:}
//	|	LCURLY SourceElements.s RCURLY
//		{:
//			return new JSStatementsNode(s);
//		:}
//	;


////////////////////////////////////
// A.5 Scripts and Modules
////////////////////////////////////
Script
	=	ScriptBody.s?
		{:
			return new JSParseRootNode(s);
		:}
	;

ScriptBody
	=	StatementList
	;

Module
	=	ModuleBody.m?
		{:
			return new JSParseRootNode(m);
		:}
	;
	
ModuleBody
	=	ModuleItemList
	;

ModuleItemList
	=	ModuleItemList ModuleItem
	|	ModuleItem
	;

ModuleItem
	=	ImportDeclaration
	|	ExportDeclaration
	|	StatementListItem
	;

ImportDeclaration
	=	IMPORT ImportClause FromClause SEMICOLON
	|	IMPORT ModuleSpecifier SEMICOLON
	;

ImportClause
	=	ImportedDefaultBinding
	|	NameSpaceImport
	|	NamedImports
	|	ImportedDefaultBinding COMMA NameSpaceImport
	|	ImportedDefaultBinding COMMA NamedImports
	;

ImportedDefaultBinding
	=	ImportedBinding
	;

NameSpaceImport
	=	STAR AS ImportedBinding
	;

NamedImports
	=	LCURLY RCURLY
	|	LCURLY ImportsList RCURLY
	|	LCURLY ImportsList COMMA RCURLY
	;

FromClause
	=	FROM ModuleSpecifier
	;

ImportsList
	=	ImportsList COMMA ImportSpecifier
	|	ImportSpecifier
	;

ImportSpecifier
	=	IdentifierName AS ImportedBinding
	|	ImportedBinding
	;

ModuleSpecifier
	=	STRING
	;

ImportedBinding
	=	Identifier
	;

ExportDeclaration
	=	EXPORT STAR FromClause SEMICOLON
	|	EXPORT ExportClause FromClause SEMICOLON
	|	EXPORT ExportClause SEMICOLON
	|	EXPORT VariableStatement
	|	EXPORT Declaration
	|	EXPORT DEFAULT HoistableDeclaration
	|	EXPORT DEFAULT ClassExpression
	|	EXPORT DEFAULT Identifier SingleExpression SEMICOLON
	;

ExportClause
	=	LCURLY RCURLY
	|	LCURLY ExportsList RCURLY
	|	LCURLY ExportsList COMMA RCURLY
	;
	
ExportsList
	=	ExportsList COMMA ExportSpecifier
	|	ExportSpecifier
	;

ExportSpecifier
	=	IdentifierName AS IdentifierName
	|	IdentifierName
	;

////////////////////////////////////
// TODO A.6 Number Conversions
////////////////////////////////////

NoSubstitutionTemplate
	=	 NO_SUB_TEMPLATE
	;

TemplateHead
	=	TEMPLATE_HEAD
	;
	
TemplateMiddle
	=	TEMPLATE_MIDDLE
	;

TemplateTail
	=	TEMPLATE_TAIL
	;