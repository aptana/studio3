==PREFS==
js.formatter.spaces.after.commas=1
js.formatter.spaces.after.assignment.operator=1
js.formatter.spaces.after.arithmetic.operator=1
js.formatter.spaces.after.conditional.operator=1
js.formatter.indent.case.body=true
js.formatter.indent.switch.body=true
js.formatter.spaces.before.for.semicolon.operator=0
js.formatter.spaces.before.parentheses=0
js.formatter.spaces.after.semicolon.operator=1
js.formatter.spaces.before.postfix.operator=0
js.formatter.spaces.after.postfix.operator=0
js.formatter.spaces.before.relational.operator=1
js.formatter.spaces.before.case.colon.operator=1
js.formatter.spaces.before.unary.operator=0
js.formatter.wrap.comments=false
js.formatter.indent.group.body=true
js.formatter.line.after.function.declaration=1
js.formatter.spaces.after.concatenation.operator=1
js.formatter.wrap.comments.length=80
js.formatter.spaces.before.conditional.operator=1
js.formatter.formatter.tabulation.size=4
js.formatter.spaces.after.relational.operator=1
js.formatter.spaces.after.case.colon.operator=1
js.formatter.spaces.before.prefix.operator=0
js.formatter.indent.blocks=true
js.formatter.spaces.before.concatenation.operator=1
js.formatter.line.preserve=1
js.formatter.brace.position.case.block=same.line
js.formatter.brace.position.switch.block=same.line
js.formatter.formatter.tabulation.char=editor
js.formatter.indent.function.body=true
js.formatter.line.after.function.declaration.expression=0
js.formatter.formatter.indentation.size=4
js.formatter.newline.before.name.value.pairs=true
js.formatter.spaces.after.parentheses=0
js.formatter.spaces.after.for.semicolon.operator=1
js.formatter.newline.before.if.in.elseif=false
js.formatter.spaces.before.key.value.operator=1
js.formatter.spaces.before.commas=0
js.formatter.spaces.after.unary.operator=0
js.formatter.spaces.before.arithmetic.operator=1
js.formatter.spaces.before.assignment.operator=1
js.formatter.newline.before.dowhile=false
js.formatter.newline.before.else=false
js.formatter.spaces.before.semicolon.operator=0
js.formatter.newline.before.finally=false
js.formatter.newline.before.catch=false
js.formatter.spaces.after.prefix.operator=0
js.formatter.brace.position.function.declaration=same.line
js.formatter.spaces.after.key.value.operator=1
js.formatter.brace.position.blocks=same.line
==CONTENT==
/** @namespace jQuery-1.1.3.1 */

// prevent execution of jQuery if included more than once
if(typeof window.jQuery == "undefined") {
/*
 * jQuery 1.1.3.1 - New Wave Javascript
 *
 * Copyright (c) 2007 John Resig (jquery.com)
 * Dual licensed under the MIT (MIT-LICENSE.txt)
 * and GPL (GPL-LICENSE.txt) licenses.
 *
 * $Date: 2007-07-05 00:43:24 -0400 (Thu, 05 Jul 2007) $
 * $Rev: 2243 $
 */

// Global undefined variable
window.undefined = window.undefined;
/** @id jQuery.$ */
var jQuery = function(a,c) {
	// If the context is global, return a new object
	if ( window == this || !this.init )
		return new jQuery(a,c);
	
	return this.init(a,c);
};

// Map over the $ in case of overwrite
if ( typeof $ != "undefined" )
	jQuery._$ = $;
	
// Map the jQuery namespace to the '$' one
var $ = jQuery;

jQuery.fn = jQuery.prototype = {
	init: function(a,c) {
		// Make sure that a selection was provided
		a = a || document;

		// HANDLE: $(function)
		// Shortcut for document ready
		if ( jQuery.isFunction(a) )
			return new jQuery(document)[ jQuery.fn.ready ? "ready" : "load" ]( a );

		// Handle HTML strings
		if ( typeof a  == "string" ) {
			// HANDLE: $(html) -> $(array)
			var m = /^[^<]*(<(.|\s)+>)[^>]*$/.exec(a);
			if ( m )
				a = jQuery.clean( [ m[1] ] );

			// HANDLE: $(expr)
			else
				return new jQuery( c ).find( a );
		}

		return this.setArray(
			// HANDLE: $(array)
			a.constructor == Array && a ||

			// HANDLE: $(arraylike)
			// Watch for when an array-like object is passed as the selector
			(a.jquery || a.length && a != window && !a.nodeType && a[0] != undefined && a[0].nodeType) && jQuery.makeArray( a ) ||

			// HANDLE: $(*)
			[ a ] );
	},
	
	/** @id jQuery.jquery */
	jquery: "1.1.3.1",

	/** @id jQuery.size */
	size: function() {
		return this.length;
	},
	
	/** @id jQuery.length */
	length: 0,

	/** @id jQuery.get */
	get: function( num ) {
		return num == undefined ?

			// Return a 'clean' array
			jQuery.makeArray( this ) :

			// Return just the object
			this[num];
	},
	
	/** @id jQuery.pushStack */
	pushStack: function( a ) {
		var ret = jQuery(a);
		ret.prevObject = this;
		return ret;
	},
	
	/** @id jQuery.setArray */
	setArray: function( a ) {
		this.length = 0;
		[].push.apply( this, a );
		return this;
	},
	
	/** @id jQuery.each */
	each: function( fn, args ) {
		return jQuery.each( this, fn, args );
	},
	
	/** @id jQuery.index */
	index: function( obj ) {
		var pos = -1;
		this.each(function(i){
			if ( this == obj ) pos = i;
		});
		return pos;
	},

	/** @id jQuery.attr */
	attr: function( key, value, type ) {
		var obj = key;
		
		// Look for the case where we're accessing a style value
		if ( key.constructor == String )
			if ( value == undefined )
				return this.length && jQuery[ type || "attr" ]( this[0], key ) || undefined;
			else {
				obj = {};
				obj[ key ] = value;
			}
		
		// Check to see if we're setting style values
		return this.each(function(index){
			// Set all the styles
			for ( var prop in obj )
				jQuery.attr(
					type ? this.style : this,
					prop, jQuery.prop(this, obj[prop], type, index, prop)
				);
		});
	},

	/** @id jQuery.css */
	css: function( key, value ) {
		return this.attr( key, value, "curCSS" );
	},

	/** @id jQuery.text */
	text: function(e) {
		if ( typeof e == "string" )
			return this.empty().append( document.createTextNode( e ) );

		var t = "";
		jQuery.each( e || this, function(){
			jQuery.each( this.childNodes, function(){
				if ( this.nodeType != 8 )
					t += this.nodeType != 1 ?
						this.nodeValue : jQuery.fn.text([ this ]);
			});
		});
		return t;
	},

	/** @id jQuery.wrap */
	wrap: function() {
		// The elements to wrap the target around
		var a, args = arguments;

		// Wrap each of the matched elements individually
		return this.each(function(){
			if ( !a )
				a = jQuery.clean(args, this.ownerDocument);

			// Clone the structure that we're using to wrap
			var b = a[0].cloneNode(true);

			// Insert it before the element to be wrapped
			this.parentNode.insertBefore( b, this );

			// Find the deepest point in the wrap structure
			while ( b.firstChild )
				b = b.firstChild;

			// Move the matched element to within the wrap structure
			b.appendChild( this );
		});
	},
	
	/** @id jQuery.append */
	append: function() {
		return this.domManip(arguments, true, 1, function(a){
			this.appendChild( a );
		});
	},
	
	/** @id jQuery.prepend */
	prepend: function() {
		return this.domManip(arguments, true, -1, function(a){
			this.insertBefore( a, this.firstChild );
		});
	},
	
	/** @id jQuery.before */
	before: function() {
		return this.domManip(arguments, false, 1, function(a){
			this.parentNode.insertBefore( a, this );
		});
	},
	
	/** @id jQuery.after */
	after: function() {
		return this.domManip(arguments, false, -1, function(a){
			this.parentNode.insertBefore( a, this.nextSibling );
		});
	},
	
	/** @id jQuery.end */
	end: function() {
		return this.prevObject || jQuery([]);
	},
	
	/** @id jQuery.find */
	find: function(t) {
		var data = jQuery.map(this, function(a){ return jQuery.find(t,a); });
		return this.pushStack( /[^+>] [^+>]/.test( t ) || t.indexOf("..") > -1 ?
			jQuery.unique( data ) : data );
	},
	
	/** @id jQuery.clone */
	clone: function(deep) {
		// Need to remove events on the element and its descendants
		var $this = this.add(this.find("*"));
		$this.each(function() {
			this._$events = {};
			for (var type in this.$events)
				this._$events[type] = jQuery.extend({},this.$events[type]);
		}).unbind();

		// Do the clone
		var r = this.pushStack( jQuery.map( this, function(a){
			return a.cloneNode( deep != undefined ? deep : true );
		}) );

		// Add the events back to the original and its descendants
		$this.each(function() {
			var events = this._$events;
			for (var type in events)
				for (var handler in events[type])
					jQuery.event.add(this, type, events[type][handler], events[type][handler].data);
			this._$events = null;
		});

		// Return the cloned set
		return r;
	},

	
	/** @id jQuery.filter */
	filter: function(t) {
		return this.pushStack(
			jQuery.isFunction( t ) &&
			jQuery.grep(this, function(el, index){
				return t.apply(el, [index])
			}) ||

			jQuery.multiFilter(t,this) );
	},

	/** @id jQuery.not */
	not: function(t) {
		return this.pushStack(
			t.constructor == String &&
			jQuery.multiFilter(t, this, true) ||

			jQuery.grep(this, function(a) {
				return ( t.constructor == Array || t.jquery )
					? jQuery.inArray( a, t ) < 0
					: a != t;
			})
		);
	},

	/** @id jQuery.add */
	add: function(t) {
		return this.pushStack( jQuery.merge(
			this.get(),
			t.constructor == String ?
				jQuery(t).get() :
				t.length != undefined && (!t.nodeName || t.nodeName == "FORM") ?
					t : [t] )
		);
	},
	
	/** @id jQuery.is */
	is: function(expr) {
		return expr ? jQuery.multiFilter(expr,this).length > 0 : false;
	},

	/** @id jQuery.val */
	val: function( val ) {
		return val == undefined ?
			( this.length ? this[0].value : null ) :
			this.attr( "value", val );
	},

	/** @id jQuery.html */
	html: function( val ) {
		return val == undefined ?
			( this.length ? this[0].innerHTML : null ) :
			this.empty().append( val );
	},
	
	/** @id jQuery.domManip */
	domManip: function(args, table, dir, fn){
		var clone = this.length > 1, a; 

		return this.each(function(){
			if ( !a ) {
				a = jQuery.clean(args, this.ownerDocument);
				if ( dir < 0 )
					a.reverse();
			}

			var obj = this;

			if ( table && jQuery.nodeName(this, "table") && jQuery.nodeName(a[0], "tr") )
				obj = this.getElementsByTagName("tbody")[0] || this.appendChild(document.createElement("tbody"));

			jQuery.each( a, function(){
				fn.apply( obj, [ clone ? this.cloneNode(true) : this ] );
			});

		});
	}
};

/** @id jQuery.$.extend */
jQuery.extend = jQuery.fn.extend = function() {
	// copy reference to target object
	var target = arguments[0], a = 1;

	// extend jQuery itself if only one argument is passed
	if ( arguments.length == 1 ) {
		target = this;
		a = 0;
	}
	var prop;
	while ( (prop = arguments[a++]) != null )
		// Extend the base object
		for ( var i in prop ) target[i] = prop[i];

	// Return the modified object
	return target;
};

jQuery.extend({
	
	/** @id jQuery.$.noConflict */
	noConflict: function() {
		if ( jQuery._$ )
			$ = jQuery._$;
		return jQuery;
	},

	// This may seem like some crazy code, but trust me when I say that this
	// is the only cross-browser way to do this. --John
	isFunction: function( fn ) {
		return !!fn && typeof fn != "string" && !fn.nodeName && 
			fn.constructor != Array && /function/i.test( fn + "" );
	},
	
	// check if an element is in a XML document
	isXMLDoc: function(elem) {
		return elem.tagName && elem.ownerDocument && !elem.ownerDocument.body;
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toUpperCase() == name.toUpperCase();
	},
	// args is for internal usage only
	
	/** @id jQuery.$.each */
	each: function( obj, fn, args ) {
		if ( obj.length == undefined )
			for ( var i in obj )
				fn.apply( obj[i], args || [i, obj[i]] );
		else
			for ( var i = 0, ol = obj.length; i < ol; i++ )
				if ( fn.apply( obj[i], args || [i, obj[i]] ) === false ) break;
		return obj;
	},
	
	prop: function(elem, value, type, index, prop){
			// Handle executable functions
			if ( jQuery.isFunction( value ) )
				value = value.call( elem, [index] );
				
			// exclude the following css properties to add px
			var exclude = /z-?index|font-?weight|opacity|zoom|line-?height/i;

			// Handle passing in a number to a CSS property
			return value && value.constructor == Number && type == "curCSS" && !exclude.test(prop) ?
				value + "px" :
				value;
	},

	className: {
		// internal only, use addClass("class")
		add: function( elem, c ){
			jQuery.each( c.split(/\s+/), function(i, cur){
				if ( !jQuery.className.has( elem.className, cur ) )
					elem.className += ( elem.className ? " " : "" ) + cur;
			});
		},

		// internal only, use removeClass("class")
		remove: function( elem, c ){
			elem.className = c != undefined ?
				jQuery.grep( elem.className.split(/\s+/), function(cur){
					return !jQuery.className.has( c, cur );	
				}).join(" ") : "";
		},

		// internal only, use is(".class")
		has: function( t, c ) {
			return jQuery.inArray( c, (t.className || t).toString().split(/\s+/) ) > -1;
		}
	},
	swap: function(e,o,f) {
		for ( var i in o ) {
			e.style["old"+i] = e.style[i];
			e.style[i] = o[i];
		}
		f.apply( e, [] );
		for ( var i in o )
			e.style[i] = e.style["old"+i];
	},

	css: function(e,p) {
		if ( p == "height" || p == "width" ) {
			var old = {}, oHeight, oWidth, d = ["Top","Bottom","Right","Left"];

			jQuery.each( d, function(){
				old["padding" + this] = 0;
				old["border" + this + "Width"] = 0;
			});

			jQuery.swap( e, old, function() {
				if ( jQuery(e).is(':visible') ) {
					oHeight = e.offsetHeight;
					oWidth = e.offsetWidth;
				} else {
					e = jQuery(e.cloneNode(true))
						.find(":radio").removeAttr("checked").end()
						.css({
							visibility: "hidden", position: "absolute", display: "block", right: "0", left: "0"
						}).appendTo(e.parentNode)[0];

					var parPos = jQuery.css(e.parentNode,"position") || "static";
					if ( parPos == "static" )
						e.parentNode.style.position = "relative";

					oHeight = e.clientHeight;
					oWidth = e.clientWidth;

					if ( parPos == "static" )
						e.parentNode.style.position = "static";

					e.parentNode.removeChild(e);
				}
			});

			return p == "height" ? oHeight : oWidth;
		}

		return jQuery.curCSS( e, p );
	},

	curCSS: function(elem, prop, force) {
		var ret;

		if (prop == "opacity" && jQuery.browser.msie) {
			ret = jQuery.attr(elem.style, "opacity");
			return ret == "" ? "1" : ret;
		}
		
		if (prop.match(/float/i))
			prop = jQuery.styleFloat;

		if (!force && elem.style[prop])
			ret = elem.style[prop];

		else if (document.defaultView && document.defaultView.getComputedStyle) {

			if (prop.match(/float/i))
				prop = "float";

			prop = prop.replace(/([A-Z])/g,"-$1").toLowerCase();
			var cur = document.defaultView.getComputedStyle(elem, null);

			if ( cur )
				ret = cur.getPropertyValue(prop);
			else if ( prop == "display" )
				ret = "none";
			else
				jQuery.swap(elem, { display: "block" }, function() {
				    var c = document.defaultView.getComputedStyle(this, "");
				    ret = c && c.getPropertyValue(prop) || "";
				});

		} else if (elem.currentStyle) {
			var newProp = prop.replace(/\-(\w)/g,function(m,c){return c.toUpperCase();});
			ret = elem.currentStyle[prop] || elem.currentStyle[newProp];
		}

		return ret;
	},
	
	clean: function(a, doc) {
		var r = [];
		doc = doc || document;

		jQuery.each( a, function(i,arg){
			if ( !arg ) return;

			if ( arg.constructor == Number )
				arg = arg.toString();
			
			// Convert html string into DOM nodes
			if ( typeof arg == "string" ) {
				// Trim whitespace, otherwise indexOf won't work as expected
				var s = jQuery.trim(arg).toLowerCase(), div = doc.createElement("div"), tb = [];

				var wrap =
					// option or optgroup
					!s.indexOf("<opt") &&
					[1, "<select>", "</select>"] ||
					
					!s.indexOf("<leg") &&
					[1, "<fieldset>", "</fieldset>"] ||
					
					(!s.indexOf("<thead") || !s.indexOf("<tbody") || !s.indexOf("<tfoot") || !s.indexOf("<colg")) &&
					[1, "<table>", "</table>"] ||
					
					!s.indexOf("<tr") &&
					[2, "<table><tbody>", "</tbody></table>"] ||
					
				 	// <thead> matched above
					(!s.indexOf("<td") || !s.indexOf("<th")) &&
					[3, "<table><tbody><tr>", "</tr></tbody></table>"] ||
					
					!s.indexOf("<col") &&
					[2, "<table><colgroup>", "</colgroup></table>"] ||
					
					[0,"",""];

				// Go to html and back, then peel off extra wrappers
				div.innerHTML = wrap[1] + arg + wrap[2];
				
				// Move to the right depth
				while ( wrap[0]-- )
					div = div.firstChild;
				
				// Remove IE's autoinserted <tbody> from table fragments
				if ( jQuery.browser.msie ) {
					
					// String was a <table>, *may* have spurious <tbody>
					if ( !s.indexOf("<table") && s.indexOf("<tbody") < 0 ) 
						tb = div.firstChild && div.firstChild.childNodes;
						
					// String was a bare <thead> or <tfoot>
					else if ( wrap[1] == "<table>" && s.indexOf("<tbody") < 0 )
						tb = div.childNodes;

					for ( var n = tb.length-1; n >= 0 ; --n )
						if ( jQuery.nodeName(tb[n], "tbody") && !tb[n].childNodes.length )
							tb[n].parentNode.removeChild(tb[n]);
					
				}
				
				arg = jQuery.makeArray( div.childNodes );
			}

			if ( 0 === arg.length && (!jQuery.nodeName(arg, "form") && !jQuery.nodeName(arg, "select")) )
				return;

			if ( arg[0] == undefined || jQuery.nodeName(arg, "form") || arg.options )
				r.push( arg );
			else
				r = jQuery.merge( r, arg );

		});

		return r;
	},
	
	attr: function(elem, name, value){
		var fix = jQuery.isXMLDoc(elem) ? {} : jQuery.props;
		
		// Certain attributes only work when accessed via the old DOM 0 way
		if ( fix[name] ) {
			if ( value != undefined ) elem[fix[name]] = value;
			return elem[fix[name]];

		} else if ( value == undefined && jQuery.browser.msie && jQuery.nodeName(elem, "form") && (name == "action" || name == "method") )
			return elem.getAttributeNode(name).nodeValue;

		// IE elem.getAttribute passes even for style
		else if ( elem.tagName ) {
			

			if ( value != undefined ) elem.setAttribute( name, value );
			if ( jQuery.browser.msie && /href|src/.test(name) && !jQuery.isXMLDoc(elem) ) 
				return elem.getAttribute( name, 2 );
			return elem.getAttribute( name );

		// elem is actually elem.style ... set the style
		} else {
			// IE actually uses filters for opacity
			if ( name == "opacity" && jQuery.browser.msie ) {
				if ( value != undefined ) {
					// IE has trouble with opacity if it does not have layout
					// Force it by setting the zoom level
					elem.zoom = 1; 
	
					// Set the alpha filter to set the opacity
					elem.filter = (elem.filter || "").replace(/alpha\([^)]*\)/,"") +
						(parseFloat(value).toString() == "NaN" ? "" : "alpha(opacity=" + value * 100 + ")");
				}
	
				return elem.filter ? 
					(parseFloat( elem.filter.match(/opacity=([^)]*)/)[1] ) / 100).toString() : "";
			}
			name = name.replace(/-([a-z])/ig,function(z,b){return b.toUpperCase();});
			if ( value != undefined ) elem[name] = value;
			return elem[name];
		}
	},
	
	/** @id jQuery.$.trim */
	trim: function(t){
		return t.replace(/^\s+|\s+$/g, "");
	},

	makeArray: function( a ) {
		var r = [];

		// Need to use typeof to fight Safari childNodes crashes
		if ( typeof a != "array" )
			for ( var i = 0, al = a.length; i < al; i++ )
				r.push( a[i] );
		else
			r = a.slice( 0 );

		return r;
	},

	inArray: function( b, a ) {
		for ( var i = 0, al = a.length; i < al; i++ )
			if ( a[i] == b )
				return i;
		return -1;
	},
	
	/** @id jQuery.$.merge */
	merge: function(first, second) {
		// We have to loop this way because IE & Opera overwrite the length
		// expando of getElementsByTagName
		for ( var i = 0; second[i]; i++ )
			first.push(second[i]);
		return first;
	},
	unique: function(first) {
		var r = [], num = jQuery.mergeNum++;

		for ( var i = 0, fl = first.length; i < fl; i++ )
			if ( num != first[i].mergeNum ) {
				first[i].mergeNum = num;
				r.push(first[i]);
			}

		return r;
	},

	mergeNum: 0,
	
	/** @id jQuery.$.grep */
	grep: function(elems, fn, inv) {
		// If a string is passed in for the function, make a function
		// for it (a handy shortcut)
		if ( typeof fn == "string" )
			fn = new Function("a","i","return " + fn);

		var result = [];

		// Go through the array, only saving the items
		// that pass the validator function
		for ( var i = 0, el = elems.length; i < el; i++ )
			if ( !inv && fn(elems[i],i) || inv && !fn(elems[i],i) )
				result.push( elems[i] );

		return result;
	},
	
	/** @id jQuery.$.map */
	map: function(elems, fn) {
		// If a string is passed in for the function, make a function
		// for it (a handy shortcut)
		if ( typeof fn == "string" )
			fn = new Function("a","return " + fn);

		var result = [];

		// Go through the array, translating each of the items to their
		// new value (or values).
		for ( var i = 0, el = elems.length; i < el; i++ ) {
			var val = fn(elems[i],i);

			if ( val !== null && val != undefined ) {
				if ( val.constructor != Array ) val = [val];
				result = result.concat( val );
			}
		}

		return result;
	}
});
 
/*
 * Whether the W3C compliant box model is being used.
 *
 * @property
 * @name $.boxModel
 * @type Boolean
 * @cat JavaScript
 */
new function() {
	var b = navigator.userAgent.toLowerCase();

	// Figure out what browser is being used
	
	/** @id jQuery.$.browser */
	jQuery.browser = {
		version: (b.match(/.+(?:rv|it|ra|ie)[\/: ]([\d.]+)/) || [])[1],
		safari: /webkit/.test(b),
		opera: /opera/.test(b),
		msie: /msie/.test(b) && !/opera/.test(b),
		mozilla: /mozilla/.test(b) && !/(compatible|webkit)/.test(b)
	};

	// Check to see if the W3C box model is being used
	jQuery.boxModel = !jQuery.browser.msie || document.compatMode == "CSS1Compat";

	jQuery.styleFloat = jQuery.browser.msie ? "styleFloat" : "cssFloat",

	jQuery.props = {
		"for": "htmlFor",
		"class": "className",
		"float": jQuery.styleFloat,
		cssFloat: jQuery.styleFloat,
		styleFloat: jQuery.styleFloat,
		innerHTML: "innerHTML",
		className: "className",
		value: "value",
		disabled: "disabled",
		checked: "checked",
		readonly: "readOnly",
		selected: "selected",
		maxlength: "maxLength"
	};
};

jQuery.each({
	parent: "a.parentNode",
	parents: "jQuery.parents(a)",
	next: "jQuery.nth(a,2,'nextSibling')",
	prev: "jQuery.nth(a,2,'previousSibling')",
	siblings: "jQuery.sibling(a.parentNode.firstChild,a)",
	children: "jQuery.sibling(a.firstChild)"
}, function(i,n){
	jQuery.fn[ i ] = function(a) {
		var ret = jQuery.map(this,n);
		if ( a && typeof a == "string" )
			ret = jQuery.multiFilter(a,ret);
		return this.pushStack( ret );
	};
});

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after"
}, function(i,n){
	jQuery.fn[ i ] = function(){
		var a = arguments;
		return this.each(function(){
			for ( var j = 0, al = a.length; j < al; j++ )
				jQuery(a[j])[n]( this );
		});
	};
});

jQuery.each( {
	removeAttr: function( key ) {
		jQuery.attr( this, key, "" );
		this.removeAttribute( key );
	},
	addClass: function(c){
		jQuery.className.add(this,c);
	},
	removeClass: function(c){
		jQuery.className.remove(this,c);
	},
	toggleClass: function( c ){
		jQuery.className[ jQuery.className.has(this,c) ? "remove" : "add" ](this, c);
	},
	remove: function(a){
		if ( !a || jQuery.filter( a, [this] ).r.length )
			this.parentNode.removeChild( this );
	},
	empty: function() {
		while ( this.firstChild )
			this.removeChild( this.firstChild );
	}
}, function(i,n){
	jQuery.fn[ i ] = function() {
		return this.each( n, arguments );
	};
});

jQuery.each( [ "eq", "lt", "gt", "contains" ], function(i,n){
	jQuery.fn[ n ] = function(num,fn) {
		return this.filter( ":" + n + "(" + num + ")", fn );
	};
});

jQuery.each( [ "height", "width" ], function(i,n){
	jQuery.fn[ n ] = function(h) {
		return h == undefined ?
			( this.length ? jQuery.css( this[0], n ) : null ) :
			this.css( n, h.constructor == String ? h : h + "px" );
	};
});
jQuery.extend({
	expr: {
		"": "m[2]=='*'||jQuery.nodeName(a,m[2])",
		"#": "a.getAttribute('id')==m[2]",
		":": {
			// Position Checks
			lt: "i<m[3]-0",
			gt: "i>m[3]-0",
			nth: "m[3]-0==i",
			eq: "m[3]-0==i",
			first: "i==0",
			last: "i==r.length-1",
			even: "i%2==0",
			odd: "i%2",

			// Child Checks
			"first-child": "a.parentNode.getElementsByTagName('*')[0]==a",
			"last-child": "jQuery.nth(a.parentNode.lastChild,1,'previousSibling')==a",
			"only-child": "!jQuery.nth(a.parentNode.lastChild,2,'previousSibling')",

			// Parent Checks
			parent: "a.firstChild",
			empty: "!a.firstChild",

			// Text Check
			contains: "(a.textContent||a.innerText||'').indexOf(m[3])>=0",

			// Visibility
			visible: '"hidden"!=a.type&&jQuery.css(a,"display")!="none"&&jQuery.css(a,"visibility")!="hidden"',
			hidden: '"hidden"==a.type||jQuery.css(a,"display")=="none"||jQuery.css(a,"visibility")=="hidden"',

			// Form attributes
			enabled: "!a.disabled",
			disabled: "a.disabled",
			checked: "a.checked",
			selected: "a.selected||jQuery.attr(a,'selected')",

			// Form elements
			text: "'text'==a.type",
			radio: "'radio'==a.type",
			checkbox: "'checkbox'==a.type",
			file: "'file'==a.type",
			password: "'password'==a.type",
			submit: "'submit'==a.type",
			image: "'image'==a.type",
			reset: "'reset'==a.type",
			button: '"button"==a.type||jQuery.nodeName(a,"button")',
			input: "/input|select|textarea|button/i.test(a.nodeName)"
		},
		"[": "jQuery.find(m[2],a).length"
	},
	
	// The regular expressions that power the parsing engine
	parse: [
		// Match: [@value='test'], [@foo]
		/^\[ *(@)([\w-]+) *([!*$^~=]*) *('?"?)(.*?)\4 *\]/,

		// Match: [div], [div p]
		/^(\[)\s*(.*?(\[.*?\])?[^[]*?)\s*\]/,

		// Match: :contains('foo')
		/^(:)([\w-]+)\("?'?(.*?(\(.*?\))?[^(]*?)"?'?\)/,

		// Match: :even, :last-chlid, #id, .class
		new RegExp("^([:.#]*)(" + 
			( jQuery.chars = jQuery.browser.safari && jQuery.browser.version < "3.0.0" ? "\\w" : "(?:[\\w\u0128-\uFFFF*_-]|\\\\.)" ) + "+)")
	],

	multiFilter: function( expr, elems, not ) {
		var old, cur = [];

		while ( expr && expr != old ) {
			old = expr;
			var f = jQuery.filter( expr, elems, not );
			expr = f.t.replace(/^\s*,\s*/, "" );
			cur = not ? elems = f.r : jQuery.merge( cur, f.r );
		}

		return cur;
	},
	
	/** @id jQuery.$.find */
	find: function( t, context ) {
		// Quickly handle non-string expressions
		if ( typeof t != "string" )
			return [ t ];

		// Make sure that the context is a DOM Element
		if ( context && !context.nodeType )
			context = null;

		// Set the correct context (if none is provided)
		context = context || document;

		// Handle the common XPath // expression
		if ( !t.indexOf("//") ) {
			context = context.documentElement;
			t = t.substr(2,t.length);

		// And the / root expression
		} else if ( !t.indexOf("/") && !context.ownerDocument ) {
			context = context.documentElement;
			t = t.substr(1,t.length);
			if ( t.indexOf("/") >= 1 )
				t = t.substr(t.indexOf("/"),t.length);
		}

		// Initialize the search
		var ret = [context], done = [], last;

		// Continue while a selector expression exists, and while
		// we're no longer looping upon ourselves
		while ( t && last != t ) {
			var r = [];
			last = t;

			t = jQuery.trim(t).replace( /^\/\//, "" );

			var foundToken = false;

			// An attempt at speeding up child selectors that
			// point to a specific element tag
			var re = new RegExp("^[/>]\\s*(" + jQuery.chars + "+)");
			var m = re.exec(t);

			if ( m ) {
				var nodeName = m[1].toUpperCase();

				// Perform our own iteration and filter
				for ( var i = 0; ret[i]; i++ )
					for ( var c = ret[i].firstChild; c; c = c.nextSibling )
						if ( c.nodeType == 1 && (nodeName == "*" || c.nodeName.toUpperCase() == nodeName.toUpperCase()) )
							r.push( c );

				ret = r;
				t = t.replace( re, "" );
				if ( t.indexOf(" ") == 0 ) continue;
				foundToken = true;
			} else {
				re = /^((\/?\.\.)|([>\/+~]))\s*([a-z]*)/i;

				if ( (m = re.exec(t)) != null ) {
					r = [];

					var nodeName = m[4], mergeNum = jQuery.mergeNum++;
					m = m[1];

					for ( var j = 0, rl = ret.length; j < rl; j++ )
						if ( m.indexOf("..") < 0 ) {
							var n = m == "~" || m == "+" ? ret[j].nextSibling : ret[j].firstChild;
							for ( ; n; n = n.nextSibling )
								if ( n.nodeType == 1 ) {
									if ( m == "~" && n.mergeNum == mergeNum ) break;
									
									if (!nodeName || n.nodeName.toUpperCase() == nodeName.toUpperCase() ) {
										if ( m == "~" ) n.mergeNum = mergeNum;
										r.push( n );
									}
									
									if ( m == "+" ) break;
								}
						} else
							r.push( ret[j].parentNode );

					ret = r;

					// And remove the token
					t = jQuery.trim( t.replace( re, "" ) );
					foundToken = true;
				}
			}

			// See if there's still an expression, and that we haven't already
			// matched a token
			if ( t && !foundToken ) {
				// Handle multiple expressions
				if ( !t.indexOf(",") ) {
					// Clean the result set
					if ( context == ret[0] ) ret.shift();

					// Merge the result sets
					done = jQuery.merge( done, ret );

					// Reset the context
					r = ret = [context];

					// Touch up the selector string
					t = " " + t.substr(1,t.length);

				} else {
					// Optomize for the case nodeName#idName
					var re2 = new RegExp("^(" + jQuery.chars + "+)(#)(" + jQuery.chars + "+)");
					var m = re2.exec(t);
					
					// Re-organize the results, so that they're consistent
					if ( m ) {
					   m = [ 0, m[2], m[3], m[1] ];

					} else {
						// Otherwise, do a traditional filter check for
						// ID, class, and element selectors
						re2 = new RegExp("^([#.]?)(" + jQuery.chars + "*)");
						m = re2.exec(t);
					}

					m[2] = m[2].replace(/\\/g, "");

					var elem = ret[ret.length-1];

					// Try to do a global search by ID, where we can
					if ( m[1] == "#" && elem && elem.getElementById ) {
						// Optimization for HTML document case
						var oid = elem.getElementById(m[2]);
						
						// Do a quick check for the existence of the actual ID attribute
						// to avoid selecting by the name attribute in IE
						// also check to insure id is a string to avoid selecting an element with the name of 'id' inside a form
						if ( (jQuery.browser.msie||jQuery.browser.opera) && oid && typeof oid.id == "string" && oid.id != m[2] )
							oid = jQuery('[@id="'+m[2]+'"]', elem)[0];

						// Do a quick check for node name (where applicable) so
						// that div#foo searches will be really fast
						ret = r = oid && (!m[3] || jQuery.nodeName(oid, m[3])) ? [oid] : [];
					} else {
						// We need to find all descendant elements
						for ( var i = 0; ret[i]; i++ ) {
							// Grab the tag name being searched for
							var tag = m[1] != "" || m[0] == "" ? "*" : m[2];

							// Handle IE7 being really dumb about <object>s
							if ( tag == "*" && ret[i].nodeName.toLowerCase() == "object" )
								tag = "param";

							r = jQuery.merge( r, ret[i].getElementsByTagName( tag ));
						}

						// It's faster to filter by class and be done with it
						if ( m[1] == "." )
							r = jQuery.classFilter( r, m[2] );

						// Same with ID filtering
						if ( m[1] == "#" ) {
							var tmp = [];

							// Try to find the element with the ID
							for ( var i = 0; r[i]; i++ )
								if ( r[i].getAttribute("id") == m[2] ) {
									tmp = [ r[i] ];
									break;
								}

							r = tmp;
						}

						ret = r;
					}

					t = t.replace( re2, "" );
				}

			}

			// If a selector string still exists
			if ( t ) {
				// Attempt to filter it
				var val = jQuery.filter(t,r);
				ret = r = val.r;
				t = jQuery.trim(val.t);
			}
		}

		// An error occurred with the selector;
		// just return an empty set instead
		if ( t )
			ret = [];

		// Remove the root context
		if ( ret && context == ret[0] )
			ret.shift();

		// And combine the results
		done = jQuery.merge( done, ret );

		return done;
	},

	classFilter: function(r,m,not){
		m = " " + m + " ";
		var tmp = [];
		for ( var i = 0; r[i]; i++ ) {
			var pass = (" " + r[i].className + " ").indexOf( m ) >= 0;
			if ( !not && pass || not && !pass )
				tmp.push( r[i] );
		}
		return tmp;
	},

	filter: function(t,r,not) {
		var last;

		// Look for common filter expressions
		while ( t  && t != last ) {
			last = t;

			var p = jQuery.parse, m;

			for ( var i = 0; p[i]; i++ ) {
				m = p[i].exec( t );

				if ( m ) {
					// Remove what we just matched
					t = t.substring( m[0].length );

					m[2] = m[2].replace(/\\/g, "");
					break;
				}
			}

			if ( !m )
				break;

			// :not() is a special case that can be optimized by
			// keeping it out of the expression list
			if ( m[1] == ":" && m[2] == "not" )
				r = jQuery.filter(m[3], r, true).r;

			// We can get a big speed boost by filtering by class here
			else if ( m[1] == "." )
				r = jQuery.classFilter(r, m[2], not);

			else if ( m[1] == "@" ) {
				var tmp = [], type = m[3];
				
				for ( var i = 0, rl = r.length; i < rl; i++ ) {
					var a = r[i], z = a[ jQuery.props[m[2]] || m[2] ];
					
					if ( z == null || /href|src/.test(m[2]) )
						z = jQuery.attr(a,m[2]) || '';

					if ( (type == "" && !!z ||
						 type == "=" && z == m[5] ||
						 type == "!=" && z != m[5] ||
						 type == "^=" && z && !z.indexOf(m[5]) ||
						 type == "$=" && z.substr(z.length - m[5].length) == m[5] ||
						 (type == "*=" || type == "~=") && z.indexOf(m[5]) >= 0) ^ not )
							tmp.push( a );
				}
				
				r = tmp;

			// We can get a speed boost by handling nth-child here
			} else if ( m[1] == ":" && m[2] == "nth-child" ) {
				var num = jQuery.mergeNum++, tmp = [],
					test = /(\d*)n\+?(\d*)/.exec(
						m[3] == "even" && "2n" || m[3] == "odd" && "2n+1" ||
						!/\D/.test(m[3]) && "n+" + m[3] || m[3]),
					first = (test[1] || 1) - 0, last = test[2] - 0;

				for ( var i = 0, rl = r.length; i < rl; i++ ) {
					var node = r[i], parentNode = node.parentNode;

					if ( num != parentNode.mergeNum ) {
						var c = 1;

						for ( var n = parentNode.firstChild; n; n = n.nextSibling )
							if ( n.nodeType == 1 )
								n.nodeIndex = c++;

						parentNode.mergeNum = num;
					}

					var add = false;

					if ( first == 1 ) {
						if ( last == 0 || node.nodeIndex == last )
							add = true;
					} else if ( (node.nodeIndex + last) % first == 0 )
						add = true;

					if ( add ^ not )
						tmp.push( node );
				}

				r = tmp;

			// Otherwise, find the expression to execute
			} else {
				var f = jQuery.expr[m[1]];
				if ( typeof f != "string" )
					f = jQuery.expr[m[1]][m[2]];

				// Build a custom macro to enclose it
				eval("f = function(a,i){return " + f + "}");

				// Execute it against the current filter
				r = jQuery.grep( r, f, not );
			}
		}

		// Return an array of filtered elements (r)
		// and the modified expression string (t)
		return { r: r, t: t };
	},
	
	/** @id jQuery.$.parents */
	parents: function( elem ){
		var matched = [];
		var cur = elem.parentNode;
		while ( cur && cur != document ) {
			matched.push( cur );
			cur = cur.parentNode;
		}
		return matched;
	},
	
	/** @id jQuery.$.nth */
	nth: function(cur,result,dir,elem){
		result = result || 1;
		var num = 0;

		for ( ; cur; cur = cur[dir] )
			if ( cur.nodeType == 1 && ++num == result )
				break;

		return cur;
	},
	
	/** @id jQuery.$.sibling */
	sibling: function( n, elem ) {
		var r = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType == 1 && (!elem || n != elem) )
				r.push( n );
		}

		return r;
	}
});
/*
 * A number of helper functions used for managing events.
 * Many of the ideas behind this code orignated from 
 * Dean Edwards' addEvent library.
 */
jQuery.event = {

	// Bind an event to an element
	// Original by Dean Edwards
	add: function(element, type, handler, data) {
		// For whatever reason, IE has trouble passing the window object
		// around, causing it to be cloned in the process
		if ( jQuery.browser.msie && element.setInterval != undefined )
			element = window;
		
		// Make sure that the function being executed has a unique ID
		if ( !handler.guid )
			handler.guid = this.guid++;
			
		// if data is passed, bind to handler 
		if( data != undefined ) { 
        	// Create temporary function pointer to original handler 
			var fn = handler; 

			// Create unique handler function, wrapped around original handler 
			handler = function() { 
				// Pass arguments and context to original handler 
				return fn.apply(this, arguments); 
			};

			// Store data in unique handler 
			handler.data = data;

			// Set the guid of unique handler to the same of original handler, so it can be removed 
			handler.guid = fn.guid;
		}

		// Init the element's event structure
		if (!element.$events)
			element.$events = {};
		
		if (!element.$handle)
			element.$handle = function() {
				// returned undefined or false
				var val;

				// Handle the second event of a trigger and when
				// an event is called after a page has unloaded
				if ( typeof jQuery == "undefined" || jQuery.event.triggered )
				  return val;
				
				val = jQuery.event.handle.apply(element, arguments);
				
				return val;
			};

		// Get the current list of functions bound to this event
		var handlers = element.$events[type];

		// Init the event handler queue
		if (!handlers) {
			handlers = element.$events[type] = {};	
			
			// And bind the global event handler to the element
			if (element.addEventListener)
				element.addEventListener(type, element.$handle, false);
			else
				element.attachEvent("on" + type, element.$handle);
		}

		// Add the function to the element's handler list
		handlers[handler.guid] = handler;

		// Remember the function in a global list (for triggering)
		if (!this.global[type])
			this.global[type] = [];
		// Only add the element to the global list once
		if (jQuery.inArray(element, this.global[type]) == -1)
			this.global[type].push( element );
	},

	guid: 1,
	global: {},

	// Detach an event or set of events from an element
	
	
	remove: function(element, type, handler) {
		var events = element.$events, ret, index;

		if ( events ) {
			// type is actually an event object here
			if ( type && type.type ) {
				handler = type.handler;
				type = type.type;
			}
			
			if ( !type ) {
				for ( type in events )
					this.remove( element, type );

			} else if ( events[type] ) {
				// remove the given handler for the given type
				if ( handler )
					delete events[type][handler.guid];
				
				// remove all handlers for the given type
				else
					for ( handler in element.$events[type] )
						delete events[type][handler];

				// remove generic event handler if no more handlers exist
				for ( ret in events[type] ) break;
				if ( !ret ) {
					if (element.removeEventListener)
						element.removeEventListener(type, element.$handle, false);
					else
						element.detachEvent("on" + type, element.$handle);
					ret = null;
					delete events[type];
					
					// Remove element from the global event type cache
					while ( this.global[type] && ( (index = jQuery.inArray(element, this.global[type])) >= 0 ) )
						delete this.global[type][index];
				}
			}

			// Remove the expando if it's no longer used
			for ( ret in events ) break;
			if ( !ret )
				element.$handle = element.$events = null;
		}
	},

	trigger: function(type, data, element) {
		// Clone the incoming data, if any
		data = jQuery.makeArray(data || []);

		// Handle a global trigger
		if ( !element )
			jQuery.each( this.global[type] || [], function(){
				jQuery.event.trigger( type, data, this );
			});

		// Handle triggering a single element
		else {
			var val, ret, fn = jQuery.isFunction( element[ type ] || null );
			
			// Pass along a fake event
			data.unshift( this.fix({ type: type, target: element }) );

			// Trigger the event
			if ( jQuery.isFunction(element.$handle) && (val = element.$handle.apply( element, data )) !== false )
				this.triggered = true;

			if ( fn && val !== false && !jQuery.nodeName(element, 'a') )
				element[ type ]();

			this.triggered = false;
		}
	},

	handle: function(event) {
		// returned undefined or false
		var val;

		// Empty object is for triggered events with no data
		event = jQuery.event.fix( event || window.event || {} ); 

		var c = this.$events && this.$events[event.type], args = [].slice.call( arguments, 1 );
		args.unshift( event );

		for ( var j in c ) {
			// Pass in a reference to the handler function itself
			// So that we can later remove it
			args[0].handler = c[j];
			args[0].data = c[j].data;

			if ( c[j].apply( this, args ) === false ) {
				event.preventDefault();
				event.stopPropagation();
				val = false;
			}
		}

		// Clean up added properties in IE to prevent memory leak
		if (jQuery.browser.msie)
			event.target = event.preventDefault = event.stopPropagation =
				event.handler = event.data = null;

		return val;
	},

	fix: function(event) {
		// store a copy of the original event object 
		// and clone to set read-only properties
		var originalEvent = event;
		event = jQuery.extend({}, originalEvent);
		
		// add preventDefault and stopPropagation since 
		// they will not work on the clone
		event.preventDefault = function() {
			// if preventDefault exists run it on the original event
			if (originalEvent.preventDefault)
				return originalEvent.preventDefault();
			// otherwise set the returnValue property of the original event to false (IE)
			originalEvent.returnValue = false;
		};
		event.stopPropagation = function() {
			// if stopPropagation exists run it on the original event
			if (originalEvent.stopPropagation)
				return originalEvent.stopPropagation();
			// otherwise set the cancelBubble property of the original event to true (IE)
			originalEvent.cancelBubble = true;
		};
		
		// Fix target property, if necessary
		if ( !event.target && event.srcElement )
			event.target = event.srcElement;
				
		// check if target is a textnode (safari)
		if (jQuery.browser.safari && event.target.nodeType == 3)
			event.target = originalEvent.target.parentNode;

		// Add relatedTarget, if necessary
		if ( !event.relatedTarget && event.fromElement )
			event.relatedTarget = event.fromElement == event.target ? event.toElement : event.fromElement;

		// Calculate pageX/Y if missing and clientX/Y available
		if ( event.pageX == null && event.clientX != null ) {
			var e = document.documentElement, b = document.body;
			event.pageX = event.clientX + (e && e.scrollLeft || b.scrollLeft);
			event.pageY = event.clientY + (e && e.scrollTop || b.scrollTop);
		}
			
		// Add which for key events
		if ( !event.which && (event.charCode || event.keyCode) )
			event.which = event.charCode || event.keyCode;
		
		// Add metaKey to non-Mac browsers (use ctrl for PC's and Meta for Macs)
		if ( !event.metaKey && event.ctrlKey )
			event.metaKey = event.ctrlKey;

		// Add which for click: 1 == left; 2 == middle; 3 == right
		// Note: button is not normalized, so don't use it
		if ( !event.which && event.button )
			event.which = (event.button & 1 ? 1 : ( event.button & 2 ? 3 : ( event.button & 4 ? 2 : 0 ) ));
			
		return event;
	}
};

jQuery.fn.extend({
	
	/** @id jQuery.bind */
	bind: function( type, data, fn ) {
		return type == "unload" ? this.one(type, data, fn) : this.each(function(){
			jQuery.event.add( this, type, fn || data, fn && data );
		});
	},
	
	/** @id jQuery.one */
	one: function( type, data, fn ) {
		return this.each(function(){
			jQuery.event.add( this, type, function(event) {
				jQuery(this).unbind(event);
				return (fn || data).apply( this, arguments);
			}, fn && data);
		});
	},
	
	/** @id jQuery.unbind */
	unbind: function( type, fn ) {
		return this.each(function(){
			jQuery.event.remove( this, type, fn );
		});
	},
	
	/** @id jQuery.trigger */
	trigger: function( type, data ) {
		return this.each(function(){
			jQuery.event.trigger( type, data, this );
		});
	},
	
	/** @id jQuery.toggle */
	toggle: function() {
		// Save reference to arguments for access in closure
		var a = arguments;

		return this.click(function(e) {
			// Figure out which function to execute
			this.lastToggle = 0 == this.lastToggle ? 1 : 0;
			
			// Make sure that clicks stop
			e.preventDefault();
			
			// and execute the function
			return a[this.lastToggle].apply( this, [e] ) || false;
		});
	},
	
	/** @id jQuery.hover */
	hover: function(f,g) {
		
		// A private function for handling mouse 'hovering'
		function handleHover(e) {
			// Check if mouse(over|out) are still within the same parent element
			var p = e.relatedTarget;
	
			// Traverse up the tree
			while ( p && p != this ) try { p = p.parentNode } catch(e) { p = this; };
			
			// If we actually just moused on to a sub-element, ignore it
			if ( p == this ) return false;
			
			// Execute the right function
			return (e.type == "mouseover" ? f : g).apply(this, [e]);
		}
		
		// Bind the function to the two event listeners
		return this.mouseover(handleHover).mouseout(handleHover);
	},
	
	/** @id jQuery.ready */
	ready: function(f) {
		// If the DOM is already ready
		if ( jQuery.isReady )
			// Execute the function immediately
			f.apply( document, [jQuery] );
			
		// Otherwise, remember the function for later
		else
			// Add the function to the wait list
			jQuery.readyList.push(function() { return f.apply(this, [jQuery]) } );
	
		return this;
	}
});

jQuery.extend({
	/*
	 * All the code that makes DOM Ready work nicely.
	 */
	isReady: false,
	readyList: [],
	
	// Handle when the DOM is ready
	ready: function() {
		// Make sure that the DOM is not already loaded
		if ( !jQuery.isReady ) {
			// Remember that the DOM is ready
			jQuery.isReady = true;
			
			// If there are functions bound, to execute
			if ( jQuery.readyList ) {
				// Execute all of them
				jQuery.each( jQuery.readyList, function(){
					this.apply( document );
				});
				
				// Reset the list of functions
				jQuery.readyList = null;
			}
			// Remove event listener to avoid memory leak
			if ( jQuery.browser.mozilla || jQuery.browser.opera )
				document.removeEventListener( "DOMContentLoaded", jQuery.ready, false );
			
			// Remove script element used by IE hack
			if( !window.frames.length ) // don't remove if frames are present (#1187)
				jQuery(window).load(function(){ jQuery("#__ie_init").remove(); });
		}
	}
});

new function(){

	jQuery.each( ("blur,focus,load,resize,scroll,unload,click,dblclick," +
		"mousedown,mouseup,mousemove,mouseover,mouseout,change,select," + 
		"submit,keydown,keypress,keyup,error").split(","), function(i,o){
		
		// Handle event binding
		jQuery.fn[o] = function(f){
			return f ? this.bind(o, f) : this.trigger(o);
		};
			
	});
	
	// If Mozilla is used
	if ( jQuery.browser.mozilla || jQuery.browser.opera )
		// Use the handy event callback
		document.addEventListener( "DOMContentLoaded", jQuery.ready, false );
	
	// If IE is used, use the excellent hack by Matthias Miller
	// http://www.outofhanwell.com/blog/index.php?title=the_window_onload_problem_revisited
	else if ( jQuery.browser.msie ) {
	
		// Only works if you document.write() it
		document.write("<scr" + "ipt id=__ie_init defer=true " + 
			"src=//:><\/script>");
	
		// Use the defer script hack
		var script = document.getElementById("__ie_init");
		
		// script does not exist if jQuery is loaded dynamically
		if ( script ) 
			script.onreadystatechange = function() {
				if ( this.readyState != "complete" ) return;
				jQuery.ready();
			};
	
		// Clear from memory
		script = null;
	
	// If Safari  is used
	} else if ( jQuery.browser.safari )
		// Continually check to see if the document.readyState is valid
		jQuery.safariTimer = setInterval(function(){
			// loaded and complete are both valid states
			if ( document.readyState == "loaded" || 
				document.readyState == "complete" ) {
	
				// If either one are found, remove the timer
				clearInterval( jQuery.safariTimer );
				jQuery.safariTimer = null;
	
				// and execute any waiting functions
				jQuery.ready();
			}
		}, 10); 

	// A fallback to window.onload, that will always work
	jQuery.event.add( window, "load", jQuery.ready );
	
};

// Clean up after IE to avoid memory leaks
if (jQuery.browser.msie)
	jQuery(window).one("unload", function() {
		var global = jQuery.event.global;
		for ( var type in global ) {
			var els = global[type], i = els.length;
			if ( i && type != 'unload' )
				do
					els[i-1] && jQuery.event.remove(els[i-1], type);
				while (--i);
		}
	});
jQuery.fn.extend({
	
	/** @id jQuery.loadIfModified */
	loadIfModified: function( url, params, callback ) {
		this.load( url, params, callback, 1 );
	},
	load: function( url, params, callback, ifModified ) {
		if ( jQuery.isFunction( url ) )
			return this.bind("load", url);

		callback = callback || function(){};

		// Default to a GET request
		var type = "GET";

		// If the second parameter was provided
		if ( params )
			// If it's a function
			if ( jQuery.isFunction( params ) ) {
				// We assume that it's the callback
				callback = params;
				params = null;

			// Otherwise, build a param string
			} else {
				params = jQuery.param( params );
				type = "POST";
			}

		var self = this;

		// Request the remote document
		jQuery.ajax({
			url: url,
			type: type,
			data: params,
			ifModified: ifModified,
			complete: function(res, status){
				if ( status == "success" || !ifModified && status == "notmodified" )
					// Inject the HTML into all the matched elements
					self.attr("innerHTML", res.responseText)
					  // Execute all the scripts inside of the newly-injected HTML
					  .evalScripts()
					  // Execute callback
					  .each( callback, [res.responseText, status, res] );
				else
					callback.apply( self, [res.responseText, status, res] );
			}
		});
		return this;
	},
	
	/** @id jQuery.serialize */
	serialize: function() {
		return jQuery.param( this );
	},
	
	/** @id jQuery.evalScripts */
	evalScripts: function() {
		return this.find("script").each(function(){
			if ( this.src )
				jQuery.getScript( this.src );
			else
				jQuery.globalEval( this.text || this.textContent || this.innerHTML || "" );
		}).end();
	}

});

// Attach a bunch of functions for handling common AJAX events

jQuery.each( "ajaxStart,ajaxStop,ajaxComplete,ajaxError,ajaxSuccess,ajaxSend".split(","), function(i,o){
	jQuery.fn[o] = function(f){
		return this.bind(o, f);
	};
});

jQuery.extend({
	
	/** @id jQuery.$.get */
	get: function( url, data, callback, type, ifModified ) {
		// shift arguments if data argument was ommited
		if ( jQuery.isFunction( data ) ) {
			callback = data;
			data = null;
		}
		
		return jQuery.ajax({
			type: "GET",
			url: url,
			data: data,
			success: callback,
			dataType: type,
			ifModified: ifModified
		});
	},
	
	/** @id jQuery.$.getIfModified */
	getIfModified: function( url, data, callback, type ) {
		return jQuery.get(url, data, callback, type, 1);
	},
	
	/** @id jQuery.$.getScript */
	getScript: function( url, callback ) {
		return jQuery.get(url, null, callback, "script");
	},
	
	/** @id jQuery.$.getJSON */
	getJSON: function( url, data, callback ) {
		return jQuery.get(url, data, callback, "json");
	},
	
	/** @id jQuery.$.post */
	post: function( url, data, callback, type ) {
		if ( jQuery.isFunction( data ) ) {
			callback = data;
			data = {};
		}

		return jQuery.ajax({
			type: "POST",
			url: url,
			data: data,
			success: callback,
			dataType: type
		});
	},
	
	/** @id jQuery.$.ajaxTimeout */
	ajaxTimeout: function( timeout ) {
		jQuery.ajaxSettings.timeout = timeout;
	},
	
	/** @id jQuery.$.ajaxSetup */
	ajaxSetup: function( settings ) {
		jQuery.extend( jQuery.ajaxSettings, settings );
	},

	ajaxSettings: {
		global: true,
		type: "GET",
		timeout: 0,
		contentType: "application/x-www-form-urlencoded",
		processData: true,
		async: true,
		data: null
	},
	
	// Last-Modified header cache for next request
	lastModified: {},
	
	/** @id jQuery.$.ajax */
	ajax: function( s ) {
		// TODO introduce global settings, allowing the client to modify them for all requests, not only timeout
		s = jQuery.extend({}, jQuery.ajaxSettings, s);

		// if data available
		if ( s.data ) {
			// convert data if not already a string
			if (s.processData && typeof s.data != "string")
    			s.data = jQuery.param(s.data);
			// append data to url for get requests
			if( s.type.toLowerCase() == "get" ) {
				// "?" + data or "&" + data (in case there are already params)
				s.url += ((s.url.indexOf("?") > -1) ? "&" : "?") + s.data;
				// IE likes to send both get and post data, prevent this
				s.data = null;
			}
		}

		// Watch for a new set of requests
		if ( s.global && ! jQuery.active++ )
			jQuery.event.trigger( "ajaxStart" );

		var requestDone = false;

		// Create the request object; Microsoft failed to properly
		// implement the XMLHttpRequest in IE7, so we use the ActiveXObject when it is available
		var xml = window.ActiveXObject ? new ActiveXObject("Microsoft.XMLHTTP") : new XMLHttpRequest();

		// Open the socket
		xml.open(s.type, s.url, s.async);

		// Set the correct header, if data is being sent
		if ( s.data )
			xml.setRequestHeader("Content-Type", s.contentType);

		// Set the If-Modified-Since header, if ifModified mode.
		if ( s.ifModified )
			xml.setRequestHeader("If-Modified-Since",
				jQuery.lastModified[s.url] || "Thu, 01 Jan 1970 00:00:00 GMT" );

		// Set header so the called script knows that it's an XMLHttpRequest
		xml.setRequestHeader("X-Requested-With", "XMLHttpRequest");

		// Allow custom headers/mimetypes
		if( s.beforeSend )
			s.beforeSend(xml);
			
		if ( s.global )
		    jQuery.event.trigger("ajaxSend", [xml, s]);

		// Wait for a response to come back
		var onreadystatechange = function(isTimeout){
			// The transfer is complete and the data is available, or the request timed out
			if ( xml && (xml.readyState == 4 || isTimeout == "timeout") ) {
				requestDone = true;
				
				// clear poll interval
				if (ival) {
					clearInterval(ival);
					ival = null;
				}
				
				var status;
				try {
					status = jQuery.httpSuccess( xml ) && isTimeout != "timeout" ?
						s.ifModified && jQuery.httpNotModified( xml, s.url ) ? "notmodified" : "success" : "error";
					// Make sure that the request was successful or notmodified
					if ( status != "error" ) {
						// Cache Last-Modified header, if ifModified mode.
						var modRes;
						try {
							modRes = xml.getResponseHeader("Last-Modified");
						} catch(e) {} // swallow exception thrown by FF if header is not available
	
						if ( s.ifModified && modRes )
							jQuery.lastModified[s.url] = modRes;
	
						// process the data (runs the xml through httpData regardless of callback)
						var data = jQuery.httpData( xml, s.dataType );
	
						// If a local callback was specified, fire it and pass it the data
						if ( s.success )
							s.success( data, status );
	
						// Fire the global callback
						if( s.global )
							jQuery.event.trigger( "ajaxSuccess", [xml, s] );
					} else
						jQuery.handleError(s, xml, status);
				} catch(e) {
					status = "error";
					jQuery.handleError(s, xml, status, e);
				}

				// The request was completed
				if( s.global )
					jQuery.event.trigger( "ajaxComplete", [xml, s] );

				// Handle the global AJAX counter
				if ( s.global && ! --jQuery.active )
					jQuery.event.trigger( "ajaxStop" );

				// Process result
				if ( s.complete )
					s.complete(xml, status);

				// Stop memory leaks
				if(s.async)
					xml = null;
			}
		};
		
		// don't attach the handler to the request, just poll it instead
		var ival = setInterval(onreadystatechange, 13); 

		// Timeout checker
		if ( s.timeout > 0 )
			setTimeout(function(){
				// Check to see if the request is still happening
				if ( xml ) {
					// Cancel the request
					xml.abort();

					if( !requestDone )
						onreadystatechange( "timeout" );
				}
			}, s.timeout);
			
		// Send the data
		try {
			xml.send(s.data);
		} catch(e) {
			jQuery.handleError(s, xml, null, e);
		}
		
		// firefox 1.5 doesn't fire statechange for sync requests
		if ( !s.async )
			onreadystatechange();
		
		// return XMLHttpRequest to allow aborting the request etc.
		return xml;
	},

	handleError: function( s, xml, status, e ) {
		// If a local callback was specified, fire it
		if ( s.error ) s.error( xml, status, e );

		// Fire the global callback
		if ( s.global )
			jQuery.event.trigger( "ajaxError", [xml, s, e] );
	},

	// Counter for holding the number of active queries
	active: 0,

	// Determines if an XMLHttpRequest was successful or not
	httpSuccess: function( r ) {
		try {
			return !r.status && location.protocol == "file:" ||
				( r.status >= 200 && r.status < 300 ) || r.status == 304 ||
				jQuery.browser.safari && r.status == undefined;
		} catch(e){}
		return false;
	},

	// Determines if an XMLHttpRequest returns NotModified
	httpNotModified: function( xml, url ) {
		try {
			var xmlRes = xml.getResponseHeader("Last-Modified");

			// Firefox always returns 200. check Last-Modified date
			return xml.status == 304 || xmlRes == jQuery.lastModified[url] ||
				jQuery.browser.safari && xml.status == undefined;
		} catch(e){}
		return false;
	},

	/* Get the data out of an XMLHttpRequest.
	 * Return parsed XML if content-type header is "xml" and type is "xml" or omitted,
	 * otherwise return plain text.
	 * (String) data - The type of data that you're expecting back,
	 * (e.g. "xml", "html", "script")
	 */
	httpData: function( r, type ) {
		var ct = r.getResponseHeader("content-type");
		var data = !type && ct && ct.indexOf("xml") >= 0;
		data = type == "xml" || data ? r.responseXML : r.responseText;

		// If the type is "script", eval it in global context
		if ( type == "script" )
			jQuery.globalEval( data );

		// Get the JavaScript object, if JSON is used.
		if ( type == "json" )
			data = eval("(" + data + ")");

		// evaluate scripts within html
		if ( type == "html" )
			jQuery("<div>").html(data).evalScripts();

		return data;
	},

	// Serialize an array of form elements or a set of
	// key/values into a query string
	param: function( a ) {
		var s = [];

		// If an array was passed in, assume that it is an array
		// of form elements
		if ( a.constructor == Array || a.jquery )
			// Serialize the form elements
			jQuery.each( a, function(){
				s.push( encodeURIComponent(this.name) + "=" + encodeURIComponent( this.value ) );
			});

		// Otherwise, assume that it's an object of key/value pairs
		else
			// Serialize the key/values
			for ( var j in a )
				// If the value is an array then the key names need to be repeated
				if ( a[j] && a[j].constructor == Array )
					jQuery.each( a[j], function(){
						s.push( encodeURIComponent(j) + "=" + encodeURIComponent( this ) );
					});
				else
					s.push( encodeURIComponent(j) + "=" + encodeURIComponent( a[j] ) );

		// Return the resulting serialization
		return s.join("&");
	},
	
	// evalulates a script in global context
	// not reliable for safari
	globalEval: function( data ) {
		if ( window.execScript )
			window.execScript( data );
		else if ( jQuery.browser.safari )
			// safari doesn't provide a synchronous global eval
			window.setTimeout( data, 0 );
		else
			eval.call( window, data );
	}

});
jQuery.fn.extend({

	/** @id @id jQuery.show */
	show: function(speed,callback){
		return speed ?
			this.animate({
				height: "show", width: "show", opacity: "show"
			}, speed, callback) :
			
			this.filter(":hidden").each(function(){
				this.style.display = this.oldblock ? this.oldblock : "";
				if ( jQuery.css(this,"display") == "none" )
					this.style.display = "block";
			}).end();
	},

	/** @id jQuery.hide */
	hide: function(speed,callback){
		return speed ?
			this.animate({
				height: "hide", width: "hide", opacity: "hide"
			}, speed, callback) :
			
			this.filter(":visible").each(function(){
				this.oldblock = this.oldblock || jQuery.css(this,"display");
				if ( this.oldblock == "none" )
					this.oldblock = "block";
				this.style.display = "none";
			}).end();
	},

	// Save the old toggle function
	_toggle: jQuery.fn.toggle,
	toggle: function( fn, fn2 ){
		return jQuery.isFunction(fn) && jQuery.isFunction(fn2) ?
			this._toggle( fn, fn2 ) :
			fn ?
				this.animate({
					height: "toggle", width: "toggle", opacity: "toggle"
				}, fn, fn2) :
				this.each(function(){
					jQuery(this)[ jQuery(this).is(":hidden") ? "show" : "hide" ]();
				});
	},
	
	/** @id jQuery.slideDown */
	slideDown: function(speed,callback){
		return this.animate({height: "show"}, speed, callback);
	},
	
	/** @id jQuery.slideUp */
	slideUp: function(speed,callback){
		return this.animate({height: "hide"}, speed, callback);
	},
	
	/** @id jQuery.slideToggle */
	slideToggle: function(speed, callback){
		return this.animate({height: "toggle"}, speed, callback);
	},
	
	/** @id jQuery.fadeIn */
	fadeIn: function(speed, callback){
		return this.animate({opacity: "show"}, speed, callback);
	},
	
	/** @id jQuery.fadeOut */
	fadeOut: function(speed, callback){
		return this.animate({opacity: "hide"}, speed, callback);
	},
	
	/** @id jQuery.fadeTo */
	fadeTo: function(speed,to,callback){
		return this.animate({opacity: to}, speed, callback);
	},
	
	/** @id jQuery.animate */
	animate: function( prop, speed, easing, callback ) {
		return this.queue(function(){
			var hidden = jQuery(this).is(":hidden"),
				opt = jQuery.speed(speed, easing, callback),
				self = this;
			
			for ( var p in prop ) {
				if ( prop[p] == "hide" && hidden || prop[p] == "show" && !hidden )
					return jQuery.isFunction(opt.complete) && opt.complete.apply(this);

				if ( p == "height" || p == "width" ) {
					// Store display property
					opt.display = jQuery.css(this, "display");

					// Make sure that nothing sneaks out
					opt.overflow = this.style.overflow;
				}
			}

			if ( opt.overflow != null )
				this.style.overflow = "hidden";

			this.curAnim = jQuery.extend({}, prop);
			
			jQuery.each( prop, function(name, val){
				var e = new jQuery.fx( self, opt, name );
				if ( val.constructor == Number )
					e.custom( e.cur(), val );
				else
					e[ val == "toggle" ? hidden ? "show" : "hide" : val ]( prop );
			});
		});
	},
	queue: function(type,fn){
		if ( !fn ) {
			fn = type;
			type = "fx";
		}
	
		return this.each(function(){
			if ( !this.queue )
				this.queue = {};
	
			if ( !this.queue[type] )
				this.queue[type] = [];
	
			this.queue[type].push( fn );
		
			if ( this.queue[type].length == 1 )
				fn.apply(this);
		});
	}

});

jQuery.extend({
	
	speed: function(speed, easing, fn) {
		var opt = speed && speed.constructor == Object ? speed : {
			complete: fn || !fn && easing || 
				jQuery.isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && easing.constructor != Function && easing || (jQuery.easing.swing ? "swing" : "linear")
		};

		opt.duration = (opt.duration && opt.duration.constructor == Number ? 
			opt.duration : 
			{ slow: 600, fast: 200 }[opt.duration]) || 400;
	
		// Queueing
		opt.old = opt.complete;
		opt.complete = function(){
			jQuery.dequeue(this, "fx");
			if ( jQuery.isFunction( opt.old ) )
				opt.old.apply( this );
		};
	
		return opt;
	},
	
	easing: {
		linear: function( p, n, firstNum, diff ) {
			return firstNum + diff * p;
		},
		swing: function( p, n, firstNum, diff ) {
			return ((-Math.cos(p*Math.PI)/2) + 0.5) * diff + firstNum;
		}
	},
	
	queue: {},
	
	dequeue: function(elem,type){
		type = type || "fx";
	
		if ( elem.queue && elem.queue[type] ) {
			// Remove self
			elem.queue[type].shift();
	
			// Get next function
			var f = elem.queue[type][0];
		
			if ( f ) f.apply( elem );
		}
	},

	timers: [],

	/*
	 * I originally wrote fx() as a clone of moo.fx and in the process
	 * of making it small in size the code became illegible to sane
	 * people. You've been warned.
	 */
	
	fx: function( elem, options, prop ){

		var z = this;

		// The styles
		var y = elem.style;
		
		// Simple function for setting a style value
		z.a = function(){
			if ( options.step )
				options.step.apply( elem, [ z.now ] );

			if ( prop == "opacity" )
				jQuery.attr(y, "opacity", z.now); // Let attr handle opacity
			else {
				y[prop] = parseInt(z.now) + "px";
				y.display = "block"; // Set display property to block for animation
			}
		};

		// Figure out the maximum number to run to
		z.max = function(){
			return parseFloat( jQuery.css(elem,prop) );
		};

		// Get the current size
		z.cur = function(){
			var r = parseFloat( jQuery.curCSS(elem, prop) );
			return r && r > -10000 ? r : z.max();
		};

		// Start an animation from one number to another
		z.custom = function(from,to){
			z.startTime = (new Date()).getTime();
			z.now = from;
			z.a();

			jQuery.timers.push(function(){
				return z.step(from, to);
			});

			if ( jQuery.timers.length == 1 ) {
				var timer = setInterval(function(){
					var timers = jQuery.timers;
					
					for ( var i = 0; i < timers.length; i++ )
						if ( !timers[i]() )
							timers.splice(i--, 1);

					if ( !timers.length )
						clearInterval( timer );
				}, 13);
			}
		};

		// Simple 'show' function
		z.show = function(){
			if ( !elem.orig ) elem.orig = {};

			// Remember where we started, so that we can go back to it later
			elem.orig[prop] = jQuery.attr( elem.style, prop );

			options.show = true;

			// Begin the animation
			z.custom(0, this.cur());

			// Make sure that we start at a small width/height to avoid any
			// flash of content
			if ( prop != "opacity" )
				y[prop] = "1px";
			
			// Start by showing the element
			jQuery(elem).show();
		};

		// Simple 'hide' function
		z.hide = function(){
			if ( !elem.orig ) elem.orig = {};

			// Remember where we started, so that we can go back to it later
			elem.orig[prop] = jQuery.attr( elem.style, prop );

			options.hide = true;

			// Begin the animation
			z.custom(this.cur(), 0);
		};

		// Each step of an animation
		z.step = function(firstNum, lastNum){
			var t = (new Date()).getTime();

			if (t > options.duration + z.startTime) {
				z.now = lastNum;
				z.a();

				if (elem.curAnim) elem.curAnim[ prop ] = true;

				var done = true;
				for ( var i in elem.curAnim )
					if ( elem.curAnim[i] !== true )
						done = false;

				if ( done ) {
					if ( options.display != null ) {
						// Reset the overflow
						y.overflow = options.overflow;
					
						// Reset the display
						y.display = options.display;
						if ( jQuery.css(elem, "display") == "none" )
							y.display = "block";
					}

					// Hide the element if the "hide" operation was done
					if ( options.hide )
						y.display = "none";

					// Reset the properties, if the item has been hidden or shown
					if ( options.hide || options.show )
						for ( var p in elem.curAnim )
							jQuery.attr(y, p, elem.orig[p]);
				}

				// If a callback was provided, execute it
				if ( done && jQuery.isFunction( options.complete ) )
					// Execute the complete function
					options.complete.apply( elem );

				return false;
			} else {
				var n = t - this.startTime;
				// Figure out where in the animation we are and set the number
				var p = n / options.duration;
				
				// Perform the easing function, defaults to swing
				z.now = jQuery.easing[options.easing](p, n, firstNum, (lastNum-firstNum), options.duration);

				// Perform the next step of the animation
				z.a();
			}

			return true;
		};
	
	}
});
}
==FORMATTED==
/** @namespace jQuery-1.1.3.1 */

// prevent execution of jQuery if included more than once
if( typeof window.jQuery == "undefined") {
    /*
    * jQuery 1.1.3.1 - New Wave Javascript
    *
    * Copyright (c) 2007 John Resig (jquery.com)
    * Dual licensed under the MIT (MIT-LICENSE.txt)
    * and GPL (GPL-LICENSE.txt) licenses.
    *
    * $Date: 2007-07-05 00:43:24 -0400 (Thu, 05 Jul 2007) $
    * $Rev: 2243 $
    */

    // Global undefined variable
    window.undefined = window.undefined;
    /** @id jQuery.$ */
    var jQuery = function(a, c) {
        // If the context is global, return a new object
        if(window == this || !this.init)
            return new jQuery(a, c);

        return this.init(a, c);
    };

    // Map over the $ in case of overwrite
    if( typeof $ != "undefined")
        jQuery._$ = $;

    // Map the jQuery namespace to the '$' one
    var $ = jQuery;

    jQuery.fn = jQuery.prototype = {
        init : function(a, c) {
            // Make sure that a selection was provided
            a = a || document;

            // HANDLE: $(function)
            // Shortcut for document ready
            if(jQuery.isFunction(a))
                return new jQuery(document)[ jQuery.fn.ready ? "ready" : "load" ](a);

            // Handle HTML strings
            if( typeof a == "string") {
                // HANDLE: $(html) -> $(array)
                var m = /^[^<]*(<(.|\s)+>)[^>]*$/.exec(a);
                if(m)
                    a = jQuery.clean([m[1]]);

                // HANDLE: $(expr)
                else
                    return new jQuery(c).find(a);
            }

            return this.setArray(
            // HANDLE: $(array)
            a.constructor == Array && a ||

            // HANDLE: $(arraylike)
            // Watch for when an array-like object is passed as the selector
            (a.jquery || a.length && a != window && !a.nodeType && a[0] != undefined && a[0].nodeType) && jQuery.makeArray(a) ||

            // HANDLE: $(*)
            [a]);
        },

        /** @id jQuery.jquery */
        jquery : "1.1.3.1",

        /** @id jQuery.size */
        size : function() {
            return this.length;
        },

        /** @id jQuery.length */
        length : 0,

        /** @id jQuery.get */
        get : function(num) {
            return num == undefined ?

            // Return a 'clean' array
            jQuery.makeArray(this) :

            // Return just the object
            this[num];
        },

        /** @id jQuery.pushStack */
        pushStack : function(a) {
            var ret = jQuery(a);
            ret.prevObject = this;
            return ret;
        },

        /** @id jQuery.setArray */
        setArray : function(a) {
            this.length = 0;
            [].push.apply(this, a);
            return this;
        },

        /** @id jQuery.each */
        each : function(fn, args) {
            return jQuery.each(this, fn, args);
        },

        /** @id jQuery.index */
        index : function(obj) {
            var pos = -1;
            this.each(function(i) {
                if(this == obj)
                    pos = i;
            });
            return pos;
        },

        /** @id jQuery.attr */
        attr : function(key, value, type) {
            var obj = key;

            // Look for the case where we're accessing a style value
            if(key.constructor == String)
                if(value == undefined)
                    return this.length && jQuery[ type || "attr" ](this[0], key) || undefined;
                else {
                    obj = {};
                    obj[key] = value;
                }

            // Check to see if we're setting style values
            return this.each(function(index) {
                // Set all the styles
                for(var prop in obj )
                jQuery.attr( type ? this.style : this, prop, jQuery.prop(this, obj[prop], type, index, prop));
            });
        },

        /** @id jQuery.css */
        css : function(key, value) {
            return this.attr(key, value, "curCSS");
        },

        /** @id jQuery.text */
        text : function(e) {
            if( typeof e == "string")
                return this.empty().append(document.createTextNode(e));

            var t = "";
            jQuery.each(e || this, function() {
                jQuery.each(this.childNodes, function() {
                    if(this.nodeType != 8)
                        t += this.nodeType != 1 ? this.nodeValue : jQuery.fn.text([this]);
                });
            });
            return t;
        },

        /** @id jQuery.wrap */
        wrap : function() {
            // The elements to wrap the target around
            var a, args = arguments;

            // Wrap each of the matched elements individually
            return this.each(function() {
                if(!a)
                    a = jQuery.clean(args, this.ownerDocument);

                // Clone the structure that we're using to wrap
                var b = a[0].cloneNode(true);

                // Insert it before the element to be wrapped
                this.parentNode.insertBefore(b, this);

                // Find the deepest point in the wrap structure
                while(b.firstChild)
                b = b.firstChild;

                // Move the matched element to within the wrap structure
                b.appendChild(this);
            });
        },

        /** @id jQuery.append */
        append : function() {
            return this.domManip(arguments, true, 1, function(a) {
                this.appendChild(a);
            });
        },

        /** @id jQuery.prepend */
        prepend : function() {
            return this.domManip(arguments, true, -1, function(a) {
                this.insertBefore(a, this.firstChild);
            });
        },

        /** @id jQuery.before */
        before : function() {
            return this.domManip(arguments, false, 1, function(a) {
                this.parentNode.insertBefore(a, this);
            });
        },

        /** @id jQuery.after */
        after : function() {
            return this.domManip(arguments, false, -1, function(a) {
                this.parentNode.insertBefore(a, this.nextSibling);
            });
        },

        /** @id jQuery.end */
        end : function() {
            return this.prevObject || jQuery([]);
        },

        /** @id jQuery.find */
        find : function(t) {
            var data = jQuery.map(this, function(a) {
                return jQuery.find(t, a);
            });
            return this.pushStack(/[^+>] [^+>]/.test(t) || t.indexOf("..") > -1 ? jQuery.unique(data) : data);
        },

        /** @id jQuery.clone */
        clone : function(deep) {
            // Need to remove events on the element and its descendants
            var $this = this.add(this.find("*"));
            $this.each(function() {
                this._$events = {};
                for(var type in this.$events)
                this._$events[type] = jQuery.extend({}, this.$events[type]);
            }).unbind();

            // Do the clone
            var r = this.pushStack(jQuery.map(this, function(a) {
                return a.cloneNode(deep != undefined ? deep : true);
            }));

            // Add the events back to the original and its descendants
            $this.each(function() {
                var events = this._$events;
                for(var type in events)
                for(var handler in events[type])
                jQuery.event.add(this, type, events[type][handler], events[type][handler].data);
                this._$events = null;
            });

            // Return the cloned set
            return r;
        },

        /** @id jQuery.filter */
        filter : function(t) {
            return this.pushStack(jQuery.isFunction(t) && jQuery.grep(this, function(el, index) {
                return t.apply(el, [index])
            }) || jQuery.multiFilter(t, this));
        },

        /** @id jQuery.not */
        not : function(t) {
            return this.pushStack(t.constructor == String && jQuery.multiFilter(t, this, true) || jQuery.grep(this, function(a) {
                return (t.constructor == Array || t.jquery ) ? jQuery.inArray(a, t) < 0 : a != t;
            }));
        },

        /** @id jQuery.add */
        add : function(t) {
            return this.pushStack(jQuery.merge(this.get(), t.constructor == String ? jQuery(t).get() : t.length != undefined && (!t.nodeName || t.nodeName == "FORM") ? t : [t]));
        },

        /** @id jQuery.is */
        is : function(expr) {
            return expr ? jQuery.multiFilter(expr, this).length > 0 : false;
        },

        /** @id jQuery.val */
        val : function(val) {
            return val == undefined ? (this.length ? this[0].value : null ) : this.attr("value", val);
        },

        /** @id jQuery.html */
        html : function(val) {
            return val == undefined ? (this.length ? this[0].innerHTML : null ) : this.empty().append(val);
        },

        /** @id jQuery.domManip */
        domManip : function(args, table, dir, fn) {
            var clone = this.length > 1, a;

            return this.each(function() {
                if(!a) {
                    a = jQuery.clean(args, this.ownerDocument);
                    if(dir < 0)
                        a.reverse();
                }

                var obj = this;

                if(table && jQuery.nodeName(this, "table") && jQuery.nodeName(a[0], "tr"))
                    obj = this.getElementsByTagName("tbody")[0] || this.appendChild(document.createElement("tbody"));

                jQuery.each(a, function() {
                    fn.apply(obj, [ clone ? this.cloneNode(true) : this]);
                });

            });
        }
    };

    /** @id jQuery.$.extend */
    jQuery.extend = jQuery.fn.extend = function() {
        // copy reference to target object
        var target = arguments[0], a = 1;

        // extend jQuery itself if only one argument is passed
        if(arguments.length == 1) {
            target = this;
            a = 0;
        }
        var prop;
        while(( prop = arguments[a++]) != null)
        // Extend the base object
        for(var i in prop )
        target[i] = prop[i];

        // Return the modified object
        return target;
    };

    jQuery.extend({

        /** @id jQuery.$.noConflict */
        noConflict : function() {
            if(jQuery._$)
                $ = jQuery._$;
            return jQuery;
        },

        // This may seem like some crazy code, but trust me when I say that this
        // is the only cross-browser way to do this. --John
        isFunction : function(fn) {
            return !!fn && typeof fn != "string" && !fn.nodeName && fn.constructor != Array && /function/i.test(fn + "");
        },

        // check if an element is in a XML document
        isXMLDoc : function(elem) {
            return elem.tagName && elem.ownerDocument && !elem.ownerDocument.body;
        },

        nodeName : function(elem, name) {
            return elem.nodeName && elem.nodeName.toUpperCase() == name.toUpperCase();
        },
        // args is for internal usage only

        /** @id jQuery.$.each */
        each : function(obj, fn, args) {
            if(obj.length == undefined)
                for(var i in obj )
                fn.apply(obj[i], args || [i, obj[i]]);
            else
                for(var i = 0, ol = obj.length; i < ol; i++)
                    if(fn.apply(obj[i], args || [i, obj[i]]) === false)
                        break;
            return obj;
        },

        prop : function(elem, value, type, index, prop) {
            // Handle executable functions
            if(jQuery.isFunction(value))
                value = value.call(elem, [index]);

            // exclude the following css properties to add px
            var exclude = /z-?index|font-?weight|opacity|zoom|line-?height/i;

            // Handle passing in a number to a CSS property
            return value && value.constructor == Number && type == "curCSS" && !exclude.test(prop) ? value + "px" : value;
        },

        className : {
            // internal only, use addClass("class")
            add : function(elem, c) {
                jQuery.each(c.split(/\s+/), function(i, cur) {
                    if(!jQuery.className.has(elem.className, cur))
                        elem.className += (elem.className ? " " : "" ) + cur;
                });
            },

            // internal only, use removeClass("class")
            remove : function(elem, c) {
                elem.className = c != undefined ? jQuery.grep(elem.className.split(/\s+/), function(cur) {
                    return !jQuery.className.has(c, cur);
                }).join(" ") : "";
            },

            // internal only, use is(".class")
            has : function(t, c) {
                return jQuery.inArray(c, (t.className || t).toString().split(/\s+/)) > -1;
            }
        },
        swap : function(e, o, f) {
            for(var i in o ) {
                e.style["old" + i] = e.style[i];
                e.style[i] = o[i];
            }
            f.apply(e, []);
            for(var i in o )
            e.style[i] = e.style["old" + i];
        },

        css : function(e, p) {
            if(p == "height" || p == "width") {
                var old = {}, oHeight, oWidth, d = ["Top", "Bottom", "Right", "Left"];

                jQuery.each(d, function() {
                    old["padding" + this] = 0;
                    old["border" + this + "Width"] = 0;
                });

                jQuery.swap(e, old, function() {
                    if(jQuery(e).is(':visible')) {
                        oHeight = e.offsetHeight;
                        oWidth = e.offsetWidth;
                    } else {
                        e = jQuery(e.cloneNode(true))
                        .find(":radio").removeAttr("checked").end()
                        .css({
                        visibility: "hidden", position: "absolute", display: "block", right: "0", left: "0"
                        }).appendTo(e.parentNode)[0];

                        var parPos = jQuery.css(e.parentNode, "position") || "static";
                        if(parPos == "static")
                            e.parentNode.style.position = "relative";

                        oHeight = e.clientHeight;
                        oWidth = e.clientWidth;

                        if(parPos == "static")
                            e.parentNode.style.position = "static";

                        e.parentNode.removeChild(e);
                    }
                });

                return p == "height" ? oHeight : oWidth;
            }

            return jQuery.curCSS(e, p);
        },

        curCSS : function(elem, prop, force) {
            var ret;

            if(prop == "opacity" && jQuery.browser.msie) {
                ret = jQuery.attr(elem.style, "opacity");
                return ret == "" ? "1" : ret;
            }

            if(prop.match(/float/i))
                prop = jQuery.styleFloat;

            if(!force && elem.style[prop])
                ret = elem.style[prop];
            
else if(document.defaultView && document.defaultView.getComputedStyle) {

                if(prop.match(/float/i))
                    prop = "float";

                prop = prop.replace(/([A-Z])/g, "-$1").toLowerCase();
                var cur = document.defaultView.getComputedStyle(elem, null);

                if(cur)
                    ret = cur.getPropertyValue(prop);
                else if(prop == "display")
                    ret = "none";
                else
                    jQuery.swap(elem, {
                        display : "block"
                    }, function() {
                        var c = document.defaultView.getComputedStyle(this, "");
                        ret = c && c.getPropertyValue(prop) || "";
                    });

            } else if(elem.currentStyle) {
                var newProp = prop.replace(/\-(\w)/g, function(m, c) {
                    return c.toUpperCase();
                });
                ret = elem.currentStyle[prop] || elem.currentStyle[newProp];
            }

            return ret;
        },

        clean : function(a, doc) {
            var r = [];
            doc = doc || document;

            jQuery.each(a, function(i, arg) {
                if(!arg)
                    return;

                if(arg.constructor == Number)
                    arg = arg.toString();

                // Convert html string into DOM nodes
                if( typeof arg == "string") {
                    // Trim whitespace, otherwise indexOf won't work as expected
                    var s = jQuery.trim(arg).toLowerCase(), div = doc.createElement("div"), tb = [];

                    var wrap =
                    // option or optgroup
                    !s.indexOf("<opt") && [1, "<select>", "</select>"] || !s.indexOf("<leg") && [1, "<fieldset>", "</fieldset>"] || (!s.indexOf("<thead") || !s.indexOf("<tbody") || !s.indexOf("<tfoot") || !s.indexOf("<colg")) && [1, "<table>", "</table>"] || !s.indexOf("<tr") && [2, "<table><tbody>", "</tbody></table>"] ||

                    // <thead> matched above
                    (!s.indexOf("<td") || !s.indexOf("<th")) && [3, "<table><tbody><tr>", "</tr></tbody></table>"] || !s.indexOf("<col") && [2, "<table><colgroup>", "</colgroup></table>"] || [0, "", ""];

                    // Go to html and back, then peel off extra wrappers
                    div.innerHTML = wrap[1] + arg + wrap[2];

                    // Move to the right depth
                    while(wrap[0]--)
                    div = div.firstChild;

                    // Remove IE's autoinserted <tbody> from table fragments
                    if(jQuery.browser.msie) {

                        // String was a <table>, *may* have spurious <tbody>
                        if(!s.indexOf("<table") && s.indexOf("<tbody") < 0)
                            tb = div.firstChild && div.firstChild.childNodes;

                        // String was a bare <thead> or <tfoot>
                        else if(wrap[1] == "<table>" && s.indexOf("<tbody") < 0)
                            tb = div.childNodes;

                        for(var n = tb.length - 1; n >= 0; --n)
                            if(jQuery.nodeName(tb[n], "tbody") && !tb[n].childNodes.length)
                                tb[n].parentNode.removeChild(tb[n]);

                    }

                    arg = jQuery.makeArray(div.childNodes);
                }

                if(0 === arg.length && (!jQuery.nodeName(arg, "form") && !jQuery.nodeName(arg, "select")))
                    return;

                if(arg[0] == undefined || jQuery.nodeName(arg, "form") || arg.options)
                    r.push(arg);
                else
                    r = jQuery.merge(r, arg);

            });

            return r;
        },

        attr : function(elem, name, value) {
            var fix = jQuery.isXMLDoc(elem) ? {} : jQuery.props;

            // Certain attributes only work when accessed via the old DOM 0 way
            if(fix[name]) {
                if(value != undefined)
                    elem[fix[name]] = value;
                return elem[fix[name]];

            } else if(value == undefined && jQuery.browser.msie && jQuery.nodeName(elem, "form") && (name == "action" || name == "method"))
                return elem.getAttributeNode(name).nodeValue;

            // IE elem.getAttribute passes even for style
            else if(elem.tagName) {

                if(value != undefined)
                    elem.setAttribute(name, value);
                if(jQuery.browser.msie && /href|src/.test(name) && !jQuery.isXMLDoc(elem))
                    return elem.getAttribute(name, 2);
                return elem.getAttribute(name);

                // elem is actually elem.style ... set the style
            } else {
                // IE actually uses filters for opacity
                if(name == "opacity" && jQuery.browser.msie) {
                    if(value != undefined) {
                        // IE has trouble with opacity if it does not have layout
                        // Force it by setting the zoom level
                        elem.zoom = 1;

                        // Set the alpha filter to set the opacity
                        elem.filter = (elem.filter || "").replace(/alpha\([^)]*\)/, "") + (parseFloat(value).toString() == "NaN" ? "" : "alpha(opacity=" + value * 100 + ")");
                    }

                    return elem.filter ? (parseFloat(elem.filter.match(/opacity=([^)]*)/)[1]) / 100).toString() : "";
                }
                name = name.replace(/-([a-z])/ig, function(z, b) {
                    return b.toUpperCase();
                });
                if(value != undefined)
                    elem[name] = value;
                return elem[name];
            }
        },

        /** @id jQuery.$.trim */
        trim : function(t) {
            return t.replace(/^\s+|\s+$/g, "");
        },

        makeArray : function(a) {
            var r = [];

            // Need to use typeof to fight Safari childNodes crashes
            if( typeof a != "array")
                for(var i = 0, al = a.length; i < al; i++)
                    r.push(a[i]);
            else
                r = a.slice(0);

            return r;
        },

        inArray : function(b, a) {
            for(var i = 0, al = a.length; i < al; i++)
                if(a[i] == b)
                    return i;
            return -1;
        },

        /** @id jQuery.$.merge */
        merge : function(first, second) {
            // We have to loop this way because IE & Opera overwrite the length
            // expando of getElementsByTagName
            for(var i = 0; second[i]; i++)
                first.push(second[i]);
            return first;
        },
        unique : function(first) {
            var r = [], num = jQuery.mergeNum++;

            for(var i = 0, fl = first.length; i < fl; i++)
                if(num != first[i].mergeNum) {
                    first[i].mergeNum = num;
                    r.push(first[i]);
                }

            return r;
        },

        mergeNum : 0,

        /** @id jQuery.$.grep */
        grep : function(elems, fn, inv) {
            // If a string is passed in for the function, make a function
            // for it (a handy shortcut)
            if( typeof fn == "string")
                fn = new Function("a", "i", "return " + fn);

            var result = [];

            // Go through the array, only saving the items
            // that pass the validator function
            for(var i = 0, el = elems.length; i < el; i++)
                if(!inv && fn(elems[i], i) || inv && !fn(elems[i], i))
                    result.push(elems[i]);

            return result;
        },

        /** @id jQuery.$.map */
        map : function(elems, fn) {
            // If a string is passed in for the function, make a function
            // for it (a handy shortcut)
            if( typeof fn == "string")
                fn = new Function("a", "return " + fn);

            var result = [];

            // Go through the array, translating each of the items to their
            // new value (or values).
            for(var i = 0, el = elems.length; i < el; i++) {
                var val = fn(elems[i], i);

                if(val !== null && val != undefined) {
                    if(val.constructor != Array)
                        val = [val];
                    result = result.concat(val);
                }
            }

            return result;
        }
    });

    /*
     * Whether the W3C compliant box model is being used.
     *
     * @property
     * @name $.boxModel
     * @type Boolean
     * @cat JavaScript
     */
    new function() {
    var b = navigator.userAgent.toLowerCase();

    // Figure out what browser is being used

    /** @id jQuery.$.browser */
    jQuery.browser = {
    version: (b.match(/.+(?:rv|it|ra|ie)[\/: ]([\d.]+)/) || [])[1],
    safari: /webkit/.test(b),
    opera: /opera/.test(b),
    msie: /msie/.test(b) && !/opera/.test(b),
    mozilla: /mozilla/.test(b) && !/(compatible|webkit)/.test(b)
    };

    // Check to see if the W3C box model is being used
    jQuery.boxModel = !jQuery.browser.msie || document.compatMode == "CSS1Compat";

    jQuery.styleFloat = jQuery.browser.msie ? "styleFloat" : "cssFloat",

    jQuery.props = {
    "for": "htmlFor",
    "class": "className",
    "float": jQuery.styleFloat,
    cssFloat: jQuery.styleFloat,
    styleFloat: jQuery.styleFloat,
    innerHTML: "innerHTML",
    className: "className",
    value: "value",
    disabled: "disabled",
    checked: "checked",
    readonly: "readOnly",
    selected: "selected",
    maxlength: "maxLength"
    };
    };

    jQuery.each({
        parent : "a.parentNode",
        parents : "jQuery.parents(a)",
        next : "jQuery.nth(a,2,'nextSibling')",
        prev : "jQuery.nth(a,2,'previousSibling')",
        siblings : "jQuery.sibling(a.parentNode.firstChild,a)",
        children : "jQuery.sibling(a.firstChild)"
    }, function(i, n) {
        jQuery.fn[i] = function(a) {
            var ret = jQuery.map(this, n);
            if(a && typeof a == "string")
                ret = jQuery.multiFilter(a, ret);
            return this.pushStack(ret);
        };
    });

    jQuery.each({
        appendTo : "append",
        prependTo : "prepend",
        insertBefore : "before",
        insertAfter : "after"
    }, function(i, n) {
        jQuery.fn[i] = function() {
            var a = arguments;
            return this.each(function() {
                for(var j = 0, al = a.length; j < al; j++)
                    jQuery(a[j])[n](this);
            });
        };
    });

    jQuery.each({
        removeAttr : function(key) {
            jQuery.attr(this, key, "");
            this.removeAttribute(key);
        },
        addClass : function(c) {
            jQuery.className.add(this, c);
        },
        removeClass : function(c) {
            jQuery.className.remove(this, c);
        },
        toggleClass : function(c) {
            jQuery.className[ jQuery.className.has(this,c) ? "remove" : "add" ](this, c);
        },
        remove : function(a) {
            if(!a || jQuery.filter(a, [this]).r.length)
                this.parentNode.removeChild(this);
        },
        empty : function() {
            while(this.firstChild)
            this.removeChild(this.firstChild);
        }
    }, function(i, n) {
        jQuery.fn[i] = function() {
            return this.each(n, arguments);
        };
    });

    jQuery.each(["eq", "lt", "gt", "contains"], function(i, n) {
        jQuery.fn[n] = function(num, fn) {
            return this.filter(":" + n + "(" + num + ")", fn);
        };
    });

    jQuery.each(["height", "width"], function(i, n) {
        jQuery.fn[n] = function(h) {
            return h == undefined ? (this.length ? jQuery.css(this[0], n) : null ) : this.css(n, h.constructor == String ? h : h + "px");
        };
    });
    jQuery.extend({
        expr : {
            "" : "m[2]=='*'||jQuery.nodeName(a,m[2])",
            "#" : "a.getAttribute('id')==m[2]",
            ":" : {
                // Position Checks
                lt : "i<m[3]-0",
                gt : "i>m[3]-0",
                nth : "m[3]-0==i",
                eq : "m[3]-0==i",
                first : "i==0",
                last : "i==r.length-1",
                even : "i%2==0",
                odd : "i%2",

                // Child Checks
                "first-child" : "a.parentNode.getElementsByTagName('*')[0]==a",
                "last-child" : "jQuery.nth(a.parentNode.lastChild,1,'previousSibling')==a",
                "only-child" : "!jQuery.nth(a.parentNode.lastChild,2,'previousSibling')",

                // Parent Checks
                parent : "a.firstChild",
                empty : "!a.firstChild",

                // Text Check
                contains : "(a.textContent||a.innerText||'').indexOf(m[3])>=0",

                // Visibility
                visible : '"hidden"!=a.type&&jQuery.css(a,"display")!="none"&&jQuery.css(a,"visibility")!="hidden"',
                hidden : '"hidden"==a.type||jQuery.css(a,"display")=="none"||jQuery.css(a,"visibility")=="hidden"',

                // Form attributes
                enabled : "!a.disabled",
                disabled : "a.disabled",
                checked : "a.checked",
                selected : "a.selected||jQuery.attr(a,'selected')",

                // Form elements
                text : "'text'==a.type",
                radio : "'radio'==a.type",
                checkbox : "'checkbox'==a.type",
                file : "'file'==a.type",
                password : "'password'==a.type",
                submit : "'submit'==a.type",
                image : "'image'==a.type",
                reset : "'reset'==a.type",
                button : '"button"==a.type||jQuery.nodeName(a,"button")',
                input : "/input|select|textarea|button/i.test(a.nodeName)"
            },
            "[" : "jQuery.find(m[2],a).length"
        },

        // The regular expressions that power the parsing engine
        parse : [
        // Match: [@value='test'], [@foo]
        /^\[ *(@)([\w-]+) *([!*$^~=]*) *('?"?)(.*?)\4 *\]/,

        // Match: [div], [div p]
        /^(\[)\s*(.*?(\[.*?\])?[^[]*?)\s*\]/,

        // Match: :contains('foo')
        /^(:)([\w-]+)\("?'?(.*?(\(.*?\))?[^(]*?)"?'?\)/,

        // Match: :even, :last-chlid, #id, .class
        new RegExp("^([:.#]*)(" + (jQuery.chars = jQuery.browser.safari && jQuery.browser.version < "3.0.0" ? "\\w" : "(?:[\\w\u0128-\uFFFF*_-]|\\\\.)" ) + "+)")],

        multiFilter : function(expr, elems, not) {
            var old, cur = [];

            while(expr && expr != old) {
                old = expr;
                var f = jQuery.filter(expr, elems, not);
                expr = f.t.replace(/^\s*,\s*/, "");
                cur = not ? elems = f.r : jQuery.merge(cur, f.r);
            }

            return cur;
        },

        /** @id jQuery.$.find */
        find : function(t, context) {
            // Quickly handle non-string expressions
            if( typeof t != "string")
                return [t];

            // Make sure that the context is a DOM Element
            if(context && !context.nodeType)
                context = null;

            // Set the correct context (if none is provided)
            context = context || document;

            // Handle the common XPath // expression
            if(!t.indexOf("//")) {
                context = context.documentElement;
                t = t.substr(2, t.length);

                // And the / root expression
            } else if(!t.indexOf("/") && !context.ownerDocument) {
                context = context.documentElement;
                t = t.substr(1, t.length);
                if(t.indexOf("/") >= 1)
                    t = t.substr(t.indexOf("/"), t.length);
            }

            // Initialize the search
            var ret = [context], done = [], last;

            // Continue while a selector expression exists, and while
            // we're no longer looping upon ourselves
            while(t && last != t) {
                var r = [];
                last = t;

                t = jQuery.trim(t).replace(/^\/\//, "");

                var foundToken = false;

                // An attempt at speeding up child selectors that
                // point to a specific element tag
                var re = new RegExp("^[/>]\\s*(" + jQuery.chars + "+)");
                var m = re.exec(t);

                if(m) {
                    var nodeName = m[1].toUpperCase();

                    // Perform our own iteration and filter
                    for(var i = 0; ret[i]; i++)
                        for(var c = ret[i].firstChild; c; c = c.nextSibling)
                            if(c.nodeType == 1 && (nodeName == "*" || c.nodeName.toUpperCase() == nodeName.toUpperCase()))
                                r.push(c);

                    ret = r;
                    t = t.replace(re, "");
                    if(t.indexOf(" ") == 0)
                        continue;
                    foundToken = true;
                } else {
                    re = /^((\/?\.\.)|([>\/+~]))\s*([a-z]*)/i;

                    if(( m = re.exec(t)) != null) {
                        r = [];

                        var nodeName = m[4], mergeNum = jQuery.mergeNum++;
                        m = m[1];

                        for(var j = 0, rl = ret.length; j < rl; j++)
                            if(m.indexOf("..") < 0) {
                                var n = m == "~" || m == "+" ? ret[j].nextSibling : ret[j].firstChild;
                                for(; n; n = n.nextSibling)
                                    if(n.nodeType == 1) {
                                        if(m == "~" && n.mergeNum == mergeNum)
                                            break;

                                        if(!nodeName || n.nodeName.toUpperCase() == nodeName.toUpperCase()) {
                                            if(m == "~")
                                                n.mergeNum = mergeNum;
                                            r.push(n);
                                        }

                                        if(m == "+")
                                            break;
                                    }
                            } else
                                r.push(ret[j].parentNode);

                        ret = r;

                        // And remove the token
                        t = jQuery.trim(t.replace(re, ""));
                        foundToken = true;
                    }
                }

                // See if there's still an expression, and that we haven't already
                // matched a token
                if(t && !foundToken) {
                    // Handle multiple expressions
                    if(!t.indexOf(",")) {
                        // Clean the result set
                        if(context == ret[0])
                            ret.shift();

                        // Merge the result sets
                        done = jQuery.merge(done, ret);

                        // Reset the context
                        r = ret = [context];

                        // Touch up the selector string
                        t = " " + t.substr(1, t.length);

                    } else {
                        // Optomize for the case nodeName#idName
                        var re2 = new RegExp("^(" + jQuery.chars + "+)(#)(" + jQuery.chars + "+)");
                        var m = re2.exec(t);

                        // Re-organize the results, so that they're consistent
                        if(m) {
                            m = [0, m[2], m[3], m[1]];

                        } else {
                            // Otherwise, do a traditional filter check for
                            // ID, class, and element selectors
                            re2 = new RegExp("^([#.]?)(" + jQuery.chars + "*)");
                            m = re2.exec(t);
                        }

                        m[2] = m[2].replace(/\\/g, "");

                        var elem = ret[ret.length - 1];

                        // Try to do a global search by ID, where we can
                        if(m[1] == "#" && elem && elem.getElementById) {
                            // Optimization for HTML document case
                            var oid = elem.getElementById(m[2]);

                            // Do a quick check for the existence of the actual ID attribute
                            // to avoid selecting by the name attribute in IE
                            // also check to insure id is a string to avoid selecting an element with the name of 'id' inside a form
                            if((jQuery.browser.msie || jQuery.browser.opera) && oid && typeof oid.id == "string" && oid.id != m[2])
                                oid = jQuery('[@id="'+m[2]+'"]', elem)[0];

                            // Do a quick check for node name (where applicable) so
                            // that div#foo searches will be really fast
                            ret = r = oid && (!m[3] || jQuery.nodeName(oid, m[3])) ? [oid] : [];
                        } else {
                            // We need to find all descendant elements
                            for(var i = 0; ret[i]; i++) {
                                // Grab the tag name being searched for
                                var tag = m[1] != "" || m[0] == "" ? "*" : m[2];

                                // Handle IE7 being really dumb about <object>s
                                if(tag == "*" && ret[i].nodeName.toLowerCase() == "object")
                                    tag = "param";

                                r = jQuery.merge(r, ret[i].getElementsByTagName(tag));
                            }

                            // It's faster to filter by class and be done with it
                            if(m[1] == ".")
                                r = jQuery.classFilter(r, m[2]);

                            // Same with ID filtering
                            if(m[1] == "#") {
                                var tmp = [];

                                // Try to find the element with the ID
                                for(var i = 0; r[i]; i++)
                                    if(r[i].getAttribute("id") == m[2]) {
                                        tmp = [r[i]];
                                        break;
                                    }

                                r = tmp;
                            }

                            ret = r;
                        }

                        t = t.replace(re2, "");
                    }

                }

                // If a selector string still exists
                if(t) {
                    // Attempt to filter it
                    var val = jQuery.filter(t, r);
                    ret = r = val.r;
                    t = jQuery.trim(val.t);
                }
            }

            // An error occurred with the selector;
            // just return an empty set instead
            if(t)
                ret = [];

            // Remove the root context
            if(ret && context == ret[0])
                ret.shift();

            // And combine the results
            done = jQuery.merge(done, ret);

            return done;
        },

        classFilter : function(r, m, not) {
            m = " " + m + " ";
            var tmp = [];
            for(var i = 0; r[i]; i++) {
                var pass = (" " + r[i].className + " ").indexOf(m) >= 0;
                if(!not && pass || not && !pass)
                    tmp.push(r[i]);
            }
            return tmp;
        },

        filter : function(t, r, not) {
            var last;

            // Look for common filter expressions
            while(t && t != last) {
                last = t;

                var p = jQuery.parse, m;

                for(var i = 0; p[i]; i++) {
                    m = p[i].exec(t);

                    if(m) {
                        // Remove what we just matched
                        t = t.substring(m[0].length);

                        m[2] = m[2].replace(/\\/g, "");
                        break;
                    }
                }

                if(!m)
                    break;

                // :not() is a special case that can be optimized by
                // keeping it out of the expression list
                if(m[1] == ":" && m[2] == "not")
                    r = jQuery.filter(m[3], r, true).r;

                // We can get a big speed boost by filtering by class here
                else if(m[1] == ".")
                    r = jQuery.classFilter(r, m[2], not);
                
else if(m[1] == "@") {
                    var tmp = [], type = m[3];

                    for(var i = 0, rl = r.length; i < rl; i++) {
                        var a = r[i], z = a[jQuery.props[m[2]] || m[2]];

                        if(z == null || /href|src/.test(m[2]))
                            z = jQuery.attr(a, m[2]) || '';

                        if((type == "" && !!z || type == "=" && z == m[5] || type == "!=" && z != m[5] || type == "^=" && z && !z.indexOf(m[5]) || type == "$=" && z.substr(z.length - m[5].length) == m[5] || (type == "*=" || type == "~=") && z.indexOf(m[5]) >= 0) ^ not)
                            tmp.push(a);
                    }

                    r = tmp;

                    // We can get a speed boost by handling nth-child here
                } else if(m[1] == ":" && m[2] == "nth-child") {
                    var num = jQuery.mergeNum++, tmp = [], test = /(\d*)n\+?(\d*)/.exec(m[3] == "even" && "2n" || m[3] == "odd" && "2n+1" || !/\D/.test(m[3]) && "n+" + m[3] || m[3]), first = (test[1] || 1) - 0, last = test[2] - 0;

                    for(var i = 0, rl = r.length; i < rl; i++) {
                        var node = r[i], parentNode = node.parentNode;

                        if(num != parentNode.mergeNum) {
                            var c = 1;

                            for(var n = parentNode.firstChild; n; n = n.nextSibling)
                                if(n.nodeType == 1)
                                    n.nodeIndex = c++;

                            parentNode.mergeNum = num;
                        }

                        var add = false;

                        if(first == 1) {
                            if(last == 0 || node.nodeIndex == last)
                                add = true;
                        } else if((node.nodeIndex + last) % first == 0)
                            add = true;

                        if(add ^ not)
                            tmp.push(node);
                    }

                    r = tmp;

                    // Otherwise, find the expression to execute
                } else {
                    var f = jQuery.expr[m[1]];
                    if( typeof f != "string")
                        f = jQuery.expr[m[1]][m[2]];

                    // Build a custom macro to enclose it
                    eval("f = function(a,i){return " + f + "}");

                    // Execute it against the current filter
                    r = jQuery.grep(r, f, not);
                }
            }

            // Return an array of filtered elements (r)
            // and the modified expression string (t)
            return {
                r : r,
                t : t
            };
        },

        /** @id jQuery.$.parents */
        parents : function(elem) {
            var matched = [];
            var cur = elem.parentNode;
            while(cur && cur != document) {
                matched.push(cur);
                cur = cur.parentNode;
            }
            return matched;
        },

        /** @id jQuery.$.nth */
        nth : function(cur, result, dir, elem) {
            result = result || 1;
            var num = 0;

            for(; cur; cur = cur[dir])
                if(cur.nodeType == 1 && ++num == result)
                    break;

            return cur;
        },

        /** @id jQuery.$.sibling */
        sibling : function(n, elem) {
            var r = [];

            for(; n; n = n.nextSibling) {
                if(n.nodeType == 1 && (!elem || n != elem))
                    r.push(n);
            }

            return r;
        }
    });
    /*
     * A number of helper functions used for managing events.
     * Many of the ideas behind this code orignated from
     * Dean Edwards' addEvent library.
     */
    jQuery.event = {

        // Bind an event to an element
        // Original by Dean Edwards
        add : function(element, type, handler, data) {
            // For whatever reason, IE has trouble passing the window object
            // around, causing it to be cloned in the process
            if(jQuery.browser.msie && element.setInterval != undefined)
                element = window;

            // Make sure that the function being executed has a unique ID
            if(!handler.guid)
                handler.guid = this.guid++;

            // if data is passed, bind to handler
            if(data != undefined) {
                // Create temporary function pointer to original handler
                var fn = handler;

                // Create unique handler function, wrapped around original handler
                handler = function() {
                    // Pass arguments and context to original handler
                    return fn.apply(this, arguments);
                };

                // Store data in unique handler
                handler.data = data;

                // Set the guid of unique handler to the same of original handler, so it can be removed
                handler.guid = fn.guid;
            }

            // Init the element's event structure
            if(!element.$events)
                element.$events = {};

            if(!element.$handle)
                element.$handle = function() {
                    // returned undefined or false
                    var val;

                    // Handle the second event of a trigger and when
                    // an event is called after a page has unloaded
                    if( typeof jQuery == "undefined" || jQuery.event.triggered)
                        return val;

                    val = jQuery.event.handle.apply(element, arguments);

                    return val;
                };

            // Get the current list of functions bound to this event
            var handlers = element.$events[type];

            // Init the event handler queue
            if(!handlers) {
                handlers = element.$events[type] = {};

                // And bind the global event handler to the element
                if(element.addEventListener)
                    element.addEventListener(type, element.$handle, false);
                else
                    element.attachEvent("on" + type, element.$handle);
            }

            // Add the function to the element's handler list
            handlers[handler.guid] = handler;

            // Remember the function in a global list (for triggering)
            if(!this.global[type])
                this.global[type] = [];
            // Only add the element to the global list once
            if(jQuery.inArray(element, this.global[type]) == -1)
                this.global[type].push(element);
        },

        guid : 1,
        global : {},

        // Detach an event or set of events from an element

        remove : function(element, type, handler) {
            var events = element.$events, ret, index;

            if(events) {
                // type is actually an event object here
                if(type && type.type) {
                    handler = type.handler;
                    type = type.type;
                }

                if(!type) {
                    for(type in events )
                    this.remove(element, type);

                } else if(events[type]) {
                    // remove the given handler for the given type
                    if(handler)
                        delete events[type][handler.guid];

                    // remove all handlers for the given type
                    else
                        for(handler in element.$events[type] )
                        delete events[type][handler];

                    // remove generic event handler if no more handlers exist
                    for(ret in events[type] )
                    break;
                    if(!ret) {
                        if(element.removeEventListener)
                            element.removeEventListener(type, element.$handle, false);
                        else
                            element.detachEvent("on" + type, element.$handle);
                        ret = null;
                        delete events[type];

                        // Remove element from the global event type cache
                        while(this.global[type] && (( index = jQuery.inArray(element, this.global[type])) >= 0 ))
                        delete this.global[type][index];
                    }
                }

                // Remove the expando if it's no longer used
                for(ret in events )
                break;
                if(!ret)
                    element.$handle = element.$events = null;
            }
        },

        trigger : function(type, data, element) {
            // Clone the incoming data, if any
            data = jQuery.makeArray(data || []);

            // Handle a global trigger
            if(!element)
                jQuery.each(this.global[type] || [], function() {
                    jQuery.event.trigger(type, data, this);
                });

            // Handle triggering a single element
            else {
                var val, ret, fn = jQuery.isFunction(element[type] || null);

                // Pass along a fake event
                data.unshift(this.fix({
                    type : type,
                    target : element
                }));

                // Trigger the event
                if(jQuery.isFunction(element.$handle) && ( val = element.$handle.apply(element, data)) !== false)
                    this.triggered = true;

                if(fn && val !== false && !jQuery.nodeName(element, 'a'))
                    element[ type ]();

                this.triggered = false;
            }
        },

        handle : function(event) {
            // returned undefined or false
            var val;

            // Empty object is for triggered events with no data
            event = jQuery.event.fix(event || window.event || {});

            var c = this.$events && this.$events[event.type], args = [].slice.call(arguments, 1);
            args.unshift(event);

            for(var j in c ) {
                // Pass in a reference to the handler function itself
                // So that we can later remove it
                args[0].handler = c[j];
                args[0].data = c[j].data;

                if(c[j].apply(this, args) === false) {
                    event.preventDefault();
                    event.stopPropagation();
                    val = false;
                }
            }

            // Clean up added properties in IE to prevent memory leak
            if(jQuery.browser.msie)
                event.target = event.preventDefault = event.stopPropagation = event.handler = event.data = null;

            return val;
        },

        fix : function(event) {
            // store a copy of the original event object
            // and clone to set read-only properties
            var originalEvent = event;
            event = jQuery.extend({}, originalEvent);

            // add preventDefault and stopPropagation since
            // they will not work on the clone
            event.preventDefault = function() {
                // if preventDefault exists run it on the original event
                if(originalEvent.preventDefault)
                    return originalEvent.preventDefault();
                // otherwise set the returnValue property of the original event to false (IE)
                originalEvent.returnValue = false;
            };
            event.stopPropagation = function() {
                // if stopPropagation exists run it on the original event
                if(originalEvent.stopPropagation)
                    return originalEvent.stopPropagation();
                // otherwise set the cancelBubble property of the original event to true (IE)
                originalEvent.cancelBubble = true;
            };

            // Fix target property, if necessary
            if(!event.target && event.srcElement)
                event.target = event.srcElement;

            // check if target is a textnode (safari)
            if(jQuery.browser.safari && event.target.nodeType == 3)
                event.target = originalEvent.target.parentNode;

            // Add relatedTarget, if necessary
            if(!event.relatedTarget && event.fromElement)
                event.relatedTarget = event.fromElement == event.target ? event.toElement : event.fromElement;

            // Calculate pageX/Y if missing and clientX/Y available
            if(event.pageX == null && event.clientX != null) {
                var e = document.documentElement, b = document.body;
                event.pageX = event.clientX + (e && e.scrollLeft || b.scrollLeft);
                event.pageY = event.clientY + (e && e.scrollTop || b.scrollTop);
            }

            // Add which for key events
            if(!event.which && (event.charCode || event.keyCode))
                event.which = event.charCode || event.keyCode;

            // Add metaKey to non-Mac browsers (use ctrl for PC's and Meta for Macs)
            if(!event.metaKey && event.ctrlKey)
                event.metaKey = event.ctrlKey;

            // Add which for click: 1 == left; 2 == middle; 3 == right
            // Note: button is not normalized, so don't use it
            if(!event.which && event.button)
                event.which = (event.button & 1 ? 1 : (event.button & 2 ? 3 : (event.button & 4 ? 2 : 0 ) ));

            return event;
        }
    };

    jQuery.fn.extend({

        /** @id jQuery.bind */
        bind : function(type, data, fn) {
            return type == "unload" ? this.one(type, data, fn) : this.each(function() {
                jQuery.event.add(this, type, fn || data, fn && data);
            });
        },

        /** @id jQuery.one */
        one : function(type, data, fn) {
            return this.each(function() {
                jQuery.event.add(this, type, function(event) {
                    jQuery(this).unbind(event);
                    return (fn || data).apply(this, arguments);
                }, fn && data);
            });
        },

        /** @id jQuery.unbind */
        unbind : function(type, fn) {
            return this.each(function() {
                jQuery.event.remove(this, type, fn);
            });
        },

        /** @id jQuery.trigger */
        trigger : function(type, data) {
            return this.each(function() {
                jQuery.event.trigger(type, data, this);
            });
        },

        /** @id jQuery.toggle */
        toggle : function() {
            // Save reference to arguments for access in closure
            var a = arguments;

            return this.click(function(e) {
                // Figure out which function to execute
                this.lastToggle = 0 == this.lastToggle ? 1 : 0;

                // Make sure that clicks stop
                e.preventDefault();

                // and execute the function
                return a[this.lastToggle].apply(this, [e]) || false;
            });
        },

        /** @id jQuery.hover */
        hover : function(f, g) {

            // A private function for handling mouse 'hovering'
            function handleHover(e) {
                // Check if mouse(over|out) are still within the same parent element
                var p = e.relatedTarget;

                // Traverse up the tree
                while(p && p != this)
                try {
                    p = p.parentNode
                } catch(e) {
                    p = this;
                };

                // If we actually just moused on to a sub-element, ignore it
                if(p == this)
                    return false;

                // Execute the right function
                return (e.type == "mouseover" ? f : g).apply(this, [e]);
            }

            // Bind the function to the two event listeners
            return this.mouseover(handleHover).mouseout(handleHover);
        },

        /** @id jQuery.ready */
        ready : function(f) {
            // If the DOM is already ready
            if(jQuery.isReady)
                // Execute the function immediately
                f.apply(document, [jQuery]);

            // Otherwise, remember the function for later
            else
                // Add the function to the wait list
                jQuery.readyList.push(function() {
                    return f.apply(this, [jQuery])
                });

            return this;
        }
    });

    jQuery.extend({
        /*
         * All the code that makes DOM Ready work nicely.
         */
        isReady : false,
        readyList : [],

        // Handle when the DOM is ready
        ready : function() {
            // Make sure that the DOM is not already loaded
            if(!jQuery.isReady) {
                // Remember that the DOM is ready
                jQuery.isReady = true;

                // If there are functions bound, to execute
                if(jQuery.readyList) {
                    // Execute all of them
                    jQuery.each(jQuery.readyList, function() {
                        this.apply(document);
                    });

                    // Reset the list of functions
                    jQuery.readyList = null;
                }
                // Remove event listener to avoid memory leak
                if(jQuery.browser.mozilla || jQuery.browser.opera)
                    document.removeEventListener("DOMContentLoaded", jQuery.ready, false);

                // Remove script element used by IE hack
                if(!window.frames.length)// don't remove if frames are present (#1187)
                    jQuery(window).load(function() {
                        jQuery("#__ie_init").remove();
                    });
            }
        }
    });

    new function(){

    jQuery.each( ("blur,focus,load,resize,scroll,unload,click,dblclick," +
    "mousedown,mouseup,mousemove,mouseover,mouseout,change,select," +
    "submit,keydown,keypress,keyup,error").split(","), function(i,o){

    // Handle event binding
    jQuery.fn[o] = function(f){
    return f ? this.bind(o, f) : this.trigger(o);
    };

    });

    // If Mozilla is used
    if ( jQuery.browser.mozilla || jQuery.browser.opera )
    // Use the handy event callback
    document.addEventListener( "DOMContentLoaded", jQuery.ready, false );

    // If IE is used, use the excellent hack by Matthias Miller
    // http://www.outofhanwell.com/blog/index.php?title=the_window_onload_problem_revisited
    else if ( jQuery.browser.msie ) {

    // Only works if you document.write() it
    document.write("<scr" + "ipt id=__ie_init defer=true " +
    "src=//:><\/script>");

    // Use the defer script hack
    var script = document.getElementById("__ie_init");

    // script does not exist if jQuery is loaded dynamically
    if ( script )
    script.onreadystatechange = function() {
    if ( this.readyState != "complete" ) return;
    jQuery.ready();
    };

    // Clear from memory
    script = null;

    // If Safari  is used
    } else if ( jQuery.browser.safari )
    // Continually check to see if the document.readyState is valid
    jQuery.safariTimer = setInterval(function(){
    // loaded and complete are both valid states
    if ( document.readyState == "loaded" ||
    document.readyState == "complete" ) {

    // If either one are found, remove the timer
    clearInterval( jQuery.safariTimer );
    jQuery.safariTimer = null;

    // and execute any waiting functions
    jQuery.ready();
    }
    }, 10);

    // A fallback to window.onload, that will always work
    jQuery.event.add( window, "load", jQuery.ready );

    };

    // Clean up after IE to avoid memory leaks
    if(jQuery.browser.msie)
        jQuery(window).one("unload", function() {
            var global = jQuery.event.global;
            for(var type in global ) {
                var els = global[type], i = els.length;
                if(i && type != 'unload')
                    do
                        els[i - 1] && jQuery.event.remove(els[i - 1], type);
                    while (--i);
            }
        });
    jQuery.fn.extend({

        /** @id jQuery.loadIfModified */
        loadIfModified : function(url, params, callback) {
            this.load(url, params, callback, 1);
        },
        load : function(url, params, callback, ifModified) {
            if(jQuery.isFunction(url))
                return this.bind("load", url);

            callback = callback ||
            function() {
            };

            // Default to a GET request
            var type = "GET";

            // If the second parameter was provided
            if(params)
                // If it's a function
                if(jQuery.isFunction(params)) {
                    // We assume that it's the callback
                    callback = params;
                    params = null;

                    // Otherwise, build a param string
                } else {
                    params = jQuery.param(params);
                    type = "POST";
                }

            var self = this;

            // Request the remote document
            jQuery.ajax({
                url : url,
                type : type,
                data : params,
                ifModified : ifModified,
                complete : function(res, status) {
                    if(status == "success" || !ifModified && status == "notmodified")
                        // Inject the HTML into all the matched elements
                        self.attr("innerHTML", res.responseText)
                        // Execute all the scripts inside of the newly-injected HTML
                        .evalScripts()
                        // Execute callback
                        .each(callback, [res.responseText, status, res]);
                    else
                        callback.apply(self, [res.responseText, status, res]);
                }
            });
            return this;
        },

        /** @id jQuery.serialize */
        serialize : function() {
            return jQuery.param(this);
        },

        /** @id jQuery.evalScripts */
        evalScripts : function() {
            return this.find("script").each(function() {
                if(this.src)
                    jQuery.getScript(this.src);
                else
                    jQuery.globalEval(this.text || this.textContent || this.innerHTML || "");
            }).end();
        }
    });

    // Attach a bunch of functions for handling common AJAX events

    jQuery.each("ajaxStart,ajaxStop,ajaxComplete,ajaxError,ajaxSuccess,ajaxSend".split(","), function(i, o) {
        jQuery.fn[o] = function(f) {
            return this.bind(o, f);
        };
    });

    jQuery.extend({

        /** @id jQuery.$.get */
        get : function(url, data, callback, type, ifModified) {
            // shift arguments if data argument was ommited
            if(jQuery.isFunction(data)) {
                callback = data;
                data = null;
            }

            return jQuery.ajax({
                type : "GET",
                url : url,
                data : data,
                success : callback,
                dataType : type,
                ifModified : ifModified
            });
        },

        /** @id jQuery.$.getIfModified */
        getIfModified : function(url, data, callback, type) {
            return jQuery.get(url, data, callback, type, 1);
        },

        /** @id jQuery.$.getScript */
        getScript : function(url, callback) {
            return jQuery.get(url, null, callback, "script");
        },

        /** @id jQuery.$.getJSON */
        getJSON : function(url, data, callback) {
            return jQuery.get(url, data, callback, "json");
        },

        /** @id jQuery.$.post */
        post : function(url, data, callback, type) {
            if(jQuery.isFunction(data)) {
                callback = data;
                data = {};
            }

            return jQuery.ajax({
                type : "POST",
                url : url,
                data : data,
                success : callback,
                dataType : type
            });
        },

        /** @id jQuery.$.ajaxTimeout */
        ajaxTimeout : function(timeout) {
            jQuery.ajaxSettings.timeout = timeout;
        },

        /** @id jQuery.$.ajaxSetup */
        ajaxSetup : function(settings) {
            jQuery.extend(jQuery.ajaxSettings, settings);
        },

        ajaxSettings : {
            global : true,
            type : "GET",
            timeout : 0,
            contentType : "application/x-www-form-urlencoded",
            processData : true,
            async : true,
            data : null
        },

        // Last-Modified header cache for next request
        lastModified : {},

        /** @id jQuery.$.ajax */
        ajax : function(s) {
            // TODO introduce global settings, allowing the client to modify them for all requests, not only timeout
            s = jQuery.extend({}, jQuery.ajaxSettings, s);

            // if data available
            if(s.data) {
                // convert data if not already a string
                if(s.processData && typeof s.data != "string")
                    s.data = jQuery.param(s.data);
                // append data to url for get requests
                if(s.type.toLowerCase() == "get") {
                    // "?" + data or "&" + data (in case there are already params)
                    s.url += ((s.url.indexOf("?") > -1) ? "&" : "?") + s.data;
                    // IE likes to send both get and post data, prevent this
                    s.data = null;
                }
            }

            // Watch for a new set of requests
            if(s.global && !jQuery.active++)
                jQuery.event.trigger("ajaxStart");

            var requestDone = false;

            // Create the request object; Microsoft failed to properly
            // implement the XMLHttpRequest in IE7, so we use the ActiveXObject when it is available
            var xml = window.ActiveXObject ? new ActiveXObject("Microsoft.XMLHTTP") : new XMLHttpRequest();

            // Open the socket
            xml.open(s.type, s.url, s.async);

            // Set the correct header, if data is being sent
            if(s.data)
                xml.setRequestHeader("Content-Type", s.contentType);

            // Set the If-Modified-Since header, if ifModified mode.
            if(s.ifModified)
                xml.setRequestHeader("If-Modified-Since", jQuery.lastModified[s.url] || "Thu, 01 Jan 1970 00:00:00 GMT");

            // Set header so the called script knows that it's an XMLHttpRequest
            xml.setRequestHeader("X-Requested-With", "XMLHttpRequest");

            // Allow custom headers/mimetypes
            if(s.beforeSend)
                s.beforeSend(xml);

            if(s.global)
                jQuery.event.trigger("ajaxSend", [xml, s]);

            // Wait for a response to come back
            var onreadystatechange = function(isTimeout) {
                // The transfer is complete and the data is available, or the request timed out
                if(xml && (xml.readyState == 4 || isTimeout == "timeout")) {
                    requestDone = true;

                    // clear poll interval
                    if(ival) {
                        clearInterval(ival);
                        ival = null;
                    }

                    var status;
                    try {
                        status = jQuery.httpSuccess(xml) && isTimeout != "timeout" ? s.ifModified && jQuery.httpNotModified(xml, s.url) ? "notmodified" : "success" : "error";
                        // Make sure that the request was successful or notmodified
                        if(status != "error") {
                            // Cache Last-Modified header, if ifModified mode.
                            var modRes;
                            try {
                                modRes = xml.getResponseHeader("Last-Modified");
                            } catch(e) {
                            }// swallow exception thrown by FF if header is not available

                            if(s.ifModified && modRes)
                                jQuery.lastModified[s.url] = modRes;

                            // process the data (runs the xml through httpData regardless of callback)
                            var data = jQuery.httpData(xml, s.dataType);

                            // If a local callback was specified, fire it and pass it the data
                            if(s.success)
                                s.success(data, status);

                            // Fire the global callback
                            if(s.global)
                                jQuery.event.trigger("ajaxSuccess", [xml, s]);
                        } else
                            jQuery.handleError(s, xml, status);
                    } catch(e) {
                        status = "error";
                        jQuery.handleError(s, xml, status, e);
                    }

                    // The request was completed
                    if(s.global)
                        jQuery.event.trigger("ajaxComplete", [xml, s]);

                    // Handle the global AJAX counter
                    if(s.global && !--jQuery.active)
                        jQuery.event.trigger("ajaxStop");

                    // Process result
                    if(s.complete)
                        s.complete(xml, status);

                    // Stop memory leaks
                    if(s.async)
                        xml = null;
                }
            };

            // don't attach the handler to the request, just poll it instead
            var ival = setInterval(onreadystatechange, 13);

            // Timeout checker
            if(s.timeout > 0)
                setTimeout(function() {
                    // Check to see if the request is still happening
                    if(xml) {
                        // Cancel the request
                        xml.abort();

                        if(!requestDone)
                            onreadystatechange("timeout");
                    }
                }, s.timeout);

            // Send the data
            try {
                xml.send(s.data);
            } catch(e) {
                jQuery.handleError(s, xml, null, e);
            }

            // firefox 1.5 doesn't fire statechange for sync requests
            if(!s.async)
                onreadystatechange();

            // return XMLHttpRequest to allow aborting the request etc.
            return xml;
        },

        handleError : function(s, xml, status, e) {
            // If a local callback was specified, fire it
            if(s.error)
                s.error(xml, status, e);

            // Fire the global callback
            if(s.global)
                jQuery.event.trigger("ajaxError", [xml, s, e]);
        },

        // Counter for holding the number of active queries
        active : 0,

        // Determines if an XMLHttpRequest was successful or not
        httpSuccess : function(r) {
            try {
                return !r.status && location.protocol == "file:" || (r.status >= 200 && r.status < 300 ) || r.status == 304 || jQuery.browser.safari && r.status == undefined;
            } catch(e) {
            }
            return false;
        },

        // Determines if an XMLHttpRequest returns NotModified
        httpNotModified : function(xml, url) {
            try {
                var xmlRes = xml.getResponseHeader("Last-Modified");

                // Firefox always returns 200. check Last-Modified date
                return xml.status == 304 || xmlRes == jQuery.lastModified[url] || jQuery.browser.safari && xml.status == undefined;
            } catch(e) {
            }
            return false;
        },

        /* Get the data out of an XMLHttpRequest.
         * Return parsed XML if content-type header is "xml" and type is "xml" or omitted,
         * otherwise return plain text.
         * (String) data - The type of data that you're expecting back,
         * (e.g. "xml", "html", "script")
         */
        httpData : function(r, type) {
            var ct = r.getResponseHeader("content-type");
            var data = !type && ct && ct.indexOf("xml") >= 0;
            data = type == "xml" || data ? r.responseXML : r.responseText;

            // If the type is "script", eval it in global context
            if(type == "script")
                jQuery.globalEval(data);

            // Get the JavaScript object, if JSON is used.
            if(type == "json")
                data = eval("(" + data + ")");

            // evaluate scripts within html
            if(type == "html")
                jQuery("<div>").html(data).evalScripts();

            return data;
        },

        // Serialize an array of form elements or a set of
        // key/values into a query string
        param : function(a) {
            var s = [];

            // If an array was passed in, assume that it is an array
            // of form elements
            if(a.constructor == Array || a.jquery)
                // Serialize the form elements
                jQuery.each(a, function() {
                    s.push(encodeURIComponent(this.name) + "=" + encodeURIComponent(this.value));
                });

            // Otherwise, assume that it's an object of key/value pairs
            else
                // Serialize the key/values
                for(var j in a )
                // If the value is an array then the key names need to be repeated
                if(a[j] && a[j].constructor == Array)
                    jQuery.each(a[j], function() {
                        s.push(encodeURIComponent(j) + "=" + encodeURIComponent(this));
                    });
                else
                    s.push(encodeURIComponent(j) + "=" + encodeURIComponent(a[j]));

            // Return the resulting serialization
            return s.join("&");
        },

        // evalulates a script in global context
        // not reliable for safari
        globalEval : function(data) {
            if(window.execScript)
                window.execScript(data);
            else if(jQuery.browser.safari)
                // safari doesn't provide a synchronous global eval
                window.setTimeout(data, 0);
            else
                eval.call(window, data);
        }
    });
    jQuery.fn.extend({

        /** @id @id jQuery.show */
        show : function(speed, callback) {
            return speed ? this.animate({
                height : "show",
                width : "show",
                opacity : "show"
            }, speed, callback) : this.filter(":hidden").each(function() {
                this.style.display = this.oldblock ? this.oldblock : "";
                if(jQuery.css(this, "display") == "none")
                    this.style.display = "block";
            }).end();
        },

        /** @id jQuery.hide */
        hide : function(speed, callback) {
            return speed ? this.animate({
                height : "hide",
                width : "hide",
                opacity : "hide"
            }, speed, callback) : this.filter(":visible").each(function() {
                this.oldblock = this.oldblock || jQuery.css(this, "display");
                if(this.oldblock == "none")
                    this.oldblock = "block";
                this.style.display = "none";
            }).end();
        },

        // Save the old toggle function
        _toggle : jQuery.fn.toggle,
        toggle : function(fn, fn2) {
            return jQuery.isFunction(fn) && jQuery.isFunction(fn2) ? this._toggle(fn, fn2) : fn ? this.animate({
                height : "toggle",
                width : "toggle",
                opacity : "toggle"
            }, fn, fn2) : this.each(function() {
                jQuery(this)[ jQuery(this).is(":hidden") ? "show" : "hide" ]();
            });
        },

        /** @id jQuery.slideDown */
        slideDown : function(speed, callback) {
            return this.animate({
                height : "show"
            }, speed, callback);
        },

        /** @id jQuery.slideUp */
        slideUp : function(speed, callback) {
            return this.animate({
                height : "hide"
            }, speed, callback);
        },

        /** @id jQuery.slideToggle */
        slideToggle : function(speed, callback) {
            return this.animate({
                height : "toggle"
            }, speed, callback);
        },

        /** @id jQuery.fadeIn */
        fadeIn : function(speed, callback) {
            return this.animate({
                opacity : "show"
            }, speed, callback);
        },

        /** @id jQuery.fadeOut */
        fadeOut : function(speed, callback) {
            return this.animate({
                opacity : "hide"
            }, speed, callback);
        },

        /** @id jQuery.fadeTo */
        fadeTo : function(speed, to, callback) {
            return this.animate({
                opacity : to
            }, speed, callback);
        },

        /** @id jQuery.animate */
        animate : function(prop, speed, easing, callback) {
            return this.queue(function() {
                var hidden = jQuery(this).is(":hidden"), opt = jQuery.speed(speed, easing, callback), self = this;

                for(var p in prop ) {
                    if(prop[p] == "hide" && hidden || prop[p] == "show" && !hidden)
                        return jQuery.isFunction(opt.complete) && opt.complete.apply(this);

                    if(p == "height" || p == "width") {
                        // Store display property
                        opt.display = jQuery.css(this, "display");

                        // Make sure that nothing sneaks out
                        opt.overflow = this.style.overflow;
                    }
                }

                if(opt.overflow != null)
                    this.style.overflow = "hidden";

                this.curAnim = jQuery.extend({}, prop);

                jQuery.each(prop, function(name, val) {
                    var e = new jQuery.fx(self, opt, name);
                    if(val.constructor == Number)
                        e.custom(e.cur(), val);
                    else
                        e[ val == "toggle" ? hidden ? "show" : "hide" : val ](prop);
                });
            });
        },
        queue : function(type, fn) {
            if(!fn) {
                fn = type;
                type = "fx";
            }

            return this.each(function() {
                if(!this.queue)
                    this.queue = {};

                if(!this.queue[type])
                    this.queue[type] = [];

                this.queue[type].push(fn);

                if(this.queue[type].length == 1)
                    fn.apply(this);
            });
        }
    });

    jQuery.extend({

        speed : function(speed, easing, fn) {
            var opt = speed && speed.constructor == Object ? speed : {
                complete : fn || !fn && easing || jQuery.isFunction(speed) && speed,
                duration : speed,
                easing : fn && easing || easing && easing.constructor != Function && easing || (jQuery.easing.swing ? "swing" : "linear")
            };

            opt.duration = (opt.duration && opt.duration.constructor == Number ? opt.duration : { slow: 600, fast: 200 }[opt.duration]) || 400;

            // Queueing
            opt.old = opt.complete;
            opt.complete = function() {
                jQuery.dequeue(this, "fx");
                if(jQuery.isFunction(opt.old))
                    opt.old.apply(this);
            };

            return opt;
        },

        easing : {
            linear : function(p, n, firstNum, diff) {
                return firstNum + diff * p;
            },
            swing : function(p, n, firstNum, diff) {
                return ((-Math.cos(p * Math.PI) / 2) + 0.5) * diff + firstNum;
            }
        },

        queue : {},

        dequeue : function(elem, type) {
            type = type || "fx";

            if(elem.queue && elem.queue[type]) {
                // Remove self
                elem.queue[type].shift();

                // Get next function
                var f = elem.queue[type][0];

                if(f)
                    f.apply(elem);
            }
        },

        timers : [],

        /*
         * I originally wrote fx() as a clone of moo.fx and in the process
         * of making it small in size the code became illegible to sane
         * people. You've been warned.
         */

        fx : function(elem, options, prop) {

            var z = this;

            // The styles
            var y = elem.style;

            // Simple function for setting a style value
            z.a = function() {
                if(options.step)
                    options.step.apply(elem, [z.now]);

                if(prop == "opacity")
                    jQuery.attr(y, "opacity", z.now);
                // Let attr handle opacity
                else {
                    y[prop] = parseInt(z.now) + "px";
                    y.display = "block";
                    // Set display property to block for animation
                }
            };

            // Figure out the maximum number to run to
            z.max = function() {
                return parseFloat(jQuery.css(elem, prop));
            };

            // Get the current size
            z.cur = function() {
                var r = parseFloat(jQuery.curCSS(elem, prop));
                return r && r > -10000 ? r : z.max();
            };

            // Start an animation from one number to another
            z.custom = function(from, to) {
                z.startTime = (new Date()).getTime();
                z.now = from;
                z.a();

                jQuery.timers.push(function() {
                    return z.step(from, to);
                });

                if(jQuery.timers.length == 1) {
                    var timer = setInterval(function() {
                        var timers = jQuery.timers;

                        for(var i = 0; i < timers.length; i++)
                            if(!timers[i]())
                                timers.splice(i--, 1);

                        if(!timers.length)
                            clearInterval(timer);
                    }, 13);
                }
            };

            // Simple 'show' function
            z.show = function() {
                if(!elem.orig)
                    elem.orig = {};

                // Remember where we started, so that we can go back to it later
                elem.orig[prop] = jQuery.attr(elem.style, prop);

                options.show = true;

                // Begin the animation
                z.custom(0, this.cur());

                // Make sure that we start at a small width/height to avoid any
                // flash of content
                if(prop != "opacity")
                    y[prop] = "1px";

                // Start by showing the element
                jQuery(elem).show();
            };

            // Simple 'hide' function
            z.hide = function() {
                if(!elem.orig)
                    elem.orig = {};

                // Remember where we started, so that we can go back to it later
                elem.orig[prop] = jQuery.attr(elem.style, prop);

                options.hide = true;

                // Begin the animation
                z.custom(this.cur(), 0);
            };

            // Each step of an animation
            z.step = function(firstNum, lastNum) {
                var t = (new Date()).getTime();

                if(t > options.duration + z.startTime) {
                    z.now = lastNum;
                    z.a();

                    if(elem.curAnim)
                        elem.curAnim[prop] = true;

                    var done = true;
                    for(var i in elem.curAnim )
                    if(elem.curAnim[i] !== true)
                        done = false;

                    if(done) {
                        if(options.display != null) {
                            // Reset the overflow
                            y.overflow = options.overflow;

                            // Reset the display
                            y.display = options.display;
                            if(jQuery.css(elem, "display") == "none")
                                y.display = "block";
                        }

                        // Hide the element if the "hide" operation was done
                        if(options.hide)
                            y.display = "none";

                        // Reset the properties, if the item has been hidden or shown
                        if(options.hide || options.show)
                            for(var p in elem.curAnim )
                            jQuery.attr(y, p, elem.orig[p]);
                    }

                    // If a callback was provided, execute it
                    if(done && jQuery.isFunction(options.complete))
                        // Execute the complete function
                        options.complete.apply(elem);

                    return false;
                } else {
                    var n = t - this.startTime;
                    // Figure out where in the animation we are and set the number
                    var p = n / options.duration;

                    // Perform the easing function, defaults to swing
                    z.now = jQuery.easing[options.easing](p, n, firstNum, (lastNum - firstNum), options.duration);

                    // Perform the next step of the animation
                    z.a();
                }

                return true;
            };

        }
    });
}